{"title":"Лабораторна робота № 1","markdown":{"yaml":{"title":"Лабораторна робота № 1"},"headingText":"Теоретичні відомості","containsRefs":false,"markdown":"\n\n\n\n\n**Тема.** Аналіз флуктуацій часового ряду\n\n**Мета.** Навчитися використовувати аналіз флуктуацій та його похідні для отримання нелінійних характеристик часового ряду\n\n\n\n\n### Аналіз динаміки прибутків, модулів прибутків та волатильностей\n\nОстаннім часом вчені все більше цікавляться економічними часовими рядами, і відбувається це за кількох причин, зокрема: (1) економічні часові ряди, такі як індекси акцій, курсів валют, залежать від розвитку великої кількості взаємодіючих систем, і є прикладами складних систем, що широко вивчаються у науці; (2) з'явилась велика кількість доступних баз з даними про економічні системи, що містять інформацію з різними часовими шкалами (починаючи з 1 хвилини і закінчуючи 1 роком). Внаслідок цього вже на даний час існує також велика кількість розроблених методів (зокрема, у статистичній фізиці), спрямованих на отримання характеристик цін акцій чи курсів валют, що еволюціонують у часі.\n\nДослідження, проведені над часовими рядами, показують, що стохастичний процес, який лежить у основі зміни ціни, характеризується кількома ознаками. Розподіл зміни ціни має виділений хвіст порівняно із Гаусовим розподілом. Функція автокореляції зміни ціни спадає експоненційно з певним характерним часом. Однак, виявляється, що амплітуда зміни ціни, виміряна за абсолютними значеннями чи квадратами цін, показує степеневі кореляції з довго часовою персистентністю аж до кількох місяців, або навіть років. Такі довгочасові залежності краще моделюються з використанням \"додаткового процесу\", що в економічній літературі часто називається **волатильністю**. Волатильність змін ціни акції є мірою того, як сильно ринок схильний до флуктуацій, тобто відхилень ціни від попередніх значень.\n\nПершим кроком при проведенні аналізу є побудова оцінювача волатильності. Ми будемо отримувати волатильність як локальне середнє модуля зміни ціни.\n\nРозуміння статистичних властивостей волатильності має також важливе практичне застосування. Волатильність є інтересом торговців, оскільки визначає ризик і є ключовим входом практично до всіх моделей цін опціонів (вторинного цінного паперу), включаючи і класичну модель Блека-Шоулза. Без задовільних методів оцінювання волатильності трейдерам було б надзвичайно важко визначати ситуації, в яких опціони попадають в недооцінку чи переоцінку.\n\n### Визначення волатильності\n\nТермін волатильність представляє узагальнену міру величини ринкових флуктуацій (відхилень). У літературі існує досить багато визначень волатильності, проте ми будемо використовувати наступне: *волатильність є локальним середнім модуля зміни ціни на відповідному часовому інтервалі $T$, що є рухомим параметром нашої оцінки*. Для індексу $X(t)$ визначимо зміну ціни $G(t)$ як зміну логарифмів індексів,\n\n$$\nG(t) = \\ln{X(t+\\Delta t) - \\ln{X(t)}} \\cong \\left[ X(t+\\Delta t) - X(t) \\right] \\big/ X(t),\n$$ {#eq-1-1}\n\nде $\\Delta t$ є часовим інтервалом затримки. Величину ([-@eq-1-1]) називають прибутковістю (return). Якщо використовувати границі, то малі зміни $X(t)$ приблизно відповідають змінам, визначеним другою рівністю. Ми лише підраховуємо час роботи ринку, викидаємо ночі, вихідні та свята із набору даних, тобто, вважаємо, що ринок працює без перерв.\n\nМодуль $G(t)$ описує амплітуду флуктуацій. У порівнянні зі значеннями $G(t)$ їх модуль не показує глобальних трендів, але великі значення $G(t)$ відповідають крахам та великим миттєвим змінам на ринках.\n\nВизначимо волатильність як середнє від $G(t)$ для часових вікон $T = n \\cdot \\Delta t$, тобто\n\n$$\nV_{T} = \\frac{1}{n}\\sum_{t^{'}=t}^{t+n-1}\\left| G(t^{'}) \\right|,\n$$ {#eq-1-2}\n\nде $n$ є цілим числом. Таке визначення може бути ще узагальнене заміною $G(t)$ на $\\left| G(t) \\right|^{\\gamma}$, де $\\gamma > 1$ дає більш виражені великі значення $G(t)$, в той час як $0 < \\gamma < 1$ виділяє малі значення $G(t)$.\n\nУ цьому визначенні волатильності використовується два параметри: $\\Delta t$ та $n$. Параметр $n$ є шаблонним (чи модельним) часовим інтервалом для даних, а параметр $\\Delta t$ є кроком переміщення часового вікна. Зауважимо, що вказане визначення волатильності має внутрішню помилку, а саме: вибір більшого часового інтервалу $T$ веде до збільшення точності визначення волатильності. Однак, велике значення $T$ також включає погане розбиття часу на інтервали, що веде, у свою чергу, до врахування не всієї прихованої у ряді інформації.\n\n### Визначення кореляцій\n\nДля визначення кореляцій часового ряду використовується функція **автокореляції**. Саме поняття *автокореляції* означає кореляцію часового ряду самого з собою (між попередніми та наступними значеннями). Автокореляцію іноді називають *послідовною кореляцією*, що означає кореляцію між членами ряду чисел, розташованих у певному порядку. Також синонімами цього терміну є *лагова кореляція* та *персистентність*. Наприклад, часто зустрічається автокореляція геофізичних процесів, що означає перенесення залишкового процесу на наступні часові проміжки.\n\nПозитивно автокорельований часовий ряд часто називають персистентним, що значить існування тенденції слідування великих значень за великими та малих за малими, інакше позитивно корельований часовий ряд можна назвати інертним.\n\nВізьмемо $N$ пар спостережень двох змінних $x$ та $y$. Коефіцієнт кореляції між парами $x$ та $y$ визначається як\n\n$$\nr = \\left[ \\sum \\left( x_i - \\bar{x} \\right) \\left( y_i - \\bar{y} \\right) \\right] \\Bigg/ \\left[ \\sqrt{\\sum \\left( x_i - \\bar{x} \\right)^{2}} \\sqrt{\\sum \\left( y_i - \\bar{y} \\right)^{2}} \\right],\n$$ {#eq-1-3}\n\nде сума знаходиться за всіма $N$ спостереженням.\n\nТаким же чином можна визначати й автокореляцію, або ж кореляцію всередині досліджуваного часового ряду. Для автокореляції першого порядку береться лаг (часова затримка), рівний 1 часовій одиниці. Отже, автокореляція першого порядку використовує перші $N−1$ спостережень $x_t, t = 1,..., N−1$ та наступні $N−1$ спостережень $x_t , t = 2,..., N$.\n\nКореляція між $x_t$ та $x_t + 1$ визначається як\n\n$$\nr_1 = \\left[ \\sum_{t=1}^{N-1} \\left( x_t - \\bar{x} \\right) \\left( x_{t+1} - \\bar{x} \\right) \\right] \\Bigg/ \\left[ \\sum_{t=1}^{N}\\left( x_t - \\bar{x} \\right)^2 \\right],\n$$ {#eq-1-4}\n\nде $x$ --- це середнє для досліджуваного періоду.\n\nРівняння ([-@eq-1-4]) може бути узагальнене для отримання кореляції між спостереженнями, розділеними $k$ часовими інтервалами:\n\n$$\nr_k = \\left[ \\sum_{t=1}^{N-k} \\left( x_t - \\bar{x} \\right) \\left( x_{t+k} - \\bar{x} \\right) \\right] \\Bigg/ \\left[ \\sum_{t=1}^{N}\\left( x_t - \\bar{x} \\right)^2 \\right].\n$$ {#eq-5}\n\nЗначення $r_k$ називається коефіцієнтом автокореляції з лагом $k$. Графік функції автокореляції як залежності $r_k$ від $k$ також називають корелограмою.\n\n## Хід роботи\n\nДля подальшої роботи з моделювання складних систем візьмемо з основу бібліотеку `yfinance`, що дозволяє працювати з даними фінансових ринків засобами мови програмування Python.\n\n:::{.callout-note}\n## Примітка\n\n**Yahoo!, Y!Finance, and Yahoo! finance є зареєстрованими товарними знаками Yahoo, Inc.**\n\n`yfinance` не є афілійованим, схваленим або перевіреним Yahoo, Inc. Це інструмент з відкритим вихідним кодом, який використовує загальнодоступні API Yahoo, і призначений для дослідницьких та освітніх цілей.\n\nВи повинні звернутися до умов використання Yahoo! ([сюди](https://policies.yahoo.com/us/en/yahoo/terms/product-atos/apiforydn/index.htm), [сюди](https://legal.yahoo.com/us/en/yahoo/terms/otos/index.html) і [сюди](https://policies.yahoo.com/us/en/yahoo/terms/index.htm)) для отримання детальної інформації про ваші права на використання фактично завантажених даних. Пам'ятайте --- фінансовий API Yahoo! призначений лише для особистого використання\n\n:::\n\nДля встановлення бібліотеки `yfinance` можете скористатися наступною командою:\n\n[Гітхаб репозиторій](https://github.com/ranaroussi/yfinance) містить більше інформації по самій бібліотеці та помилкам, що можуть виникнути та їх потенційним рішенням.  \n\n### Вступ до модуля `Ticker()`\n\nПерш за все імпортуємо бібліотеку `yfinance` за допомогою наступної команди:\n\nМодуль `Ticker()` дозволяє отримувати ринкові та метадані для цінного паперу, використовуючи Python:\n\nМожна вилучити всю інформацію по досліджуваному індексу:\n\nМожна вилучити ринкові значення за максимальний період часу:\n\nОкрім цього, `yfinance` дозволяє отримати інформацію по дивідентам та сплітам фінансового індексу:\n\nДля методу `history()` доступні аргументи:\n\n- **period**: період даних для завантаження (або використовуйте параметр period, або використовуйте start і end). Допустимі періоди: 1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max;\n- **interval**: інтервал даних (внутрішньоденні дані не можуть перевищувати 60 днів) Допустимі інтервали 1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h, 1d, 5d, 1wk, 1mo, 3mo;\n- **start**: Якщо не використовується період --- завантажте рядок дати початку у форматі (YYYY-MM-DD) або *datetime*;\n- **end**: Якщо не використовується період --- завантажте рядок дати закінчення (YYYY-MM-DD) або *datetime*;\n- **prepost**: Включати в результати попередні та пост ринкові дані (За замовчуванням False);\n- **auto_adjust**: Автоматично налаштовувати всі OHLC (ціни відкриття, закриття, найбільшу та найменшу) (За замовчуванням True);\n- **actions**: Завантажувати події дивідендів та дроблення акцій (За замовчуванням True).\n\n### Одночасне вивантаження декількох ринкових активів\n\nЯк і до цього, ви також можете завантажувати дані для кількох тикерів одночасно:\n\nДля отримання конкретно цін закриття індексу **SPY** вам варто використовувати наступну команду: `data['Close']['SPY']`\nАле, якщо вам необхідно згрупувати дані за їх символом, можна скористатися наступним записом:\n\nТепер для звернення до цін закриття індексу **SPY** вам треба використовувати наступний запис: `data['SPY']['Close']`.\n\nМетод `download()` приймає додатковий параметр `threads` для швидшої обробки великої кількості фінансових індексів одночасно.\n\nДля подальшої роботи нас ще будуть цікавати наступні бібліотеки:\n\n- **`matplotlib`**: комплексна бібліотека для створення статичних, анімованих та інтерактивних візуалізацій на Python. Matplotlib робить прості речі простими, а складні --- можливими;\n- **`pandas`**: програмна бібліотека написана для мови програмування Python для маніпулювання та аналізу даних. Зокрема, вона пропонує структури даних та операції з числовими таблицями та часовими рядами;\n- **`numpy`**: бібліотека, що додає підтримку великих багатовимірних масивів і матриць, а також колекцію високорівневих математичних функцій для роботи з цими масивами;\n- **`neurokit2`**: зручна бібліотека, що забезпечує легкий доступ до розширених процедур обробки біосигналів. Дослідники та клініцисти без глибоких знань програмування або біомедичної обробки сигналів можуть аналізувати фізіологічні дані за допомогою лише двох рядків коду. Перевага даної бібліотеки полягає в тому, що вона надає функціонал, який можна використовувати не лише для біомедичних сигналів, але й для фінансових, фізичних тощо.\n\n\nВстановити кожну з даних бібліотек можна в наступний спосіб: `!pip install *назва бібліотеки*`:\n\nДалі нам треба буде визначити стиль рисунків для виведення та збереження. Встановимо наступну бібліотеку:\n\nІмпортуємо кожну із зазначених бібліотек:\n\nВиконаємо налаштування стилю наших подальших рисунків:\n\nПредставлені налаштування є орієнтовними і можуть змінюватись у ході наступних лабораторних роботах. Ви можете встановлювати власні налаштування. На сайті бібліотеки [matplotlib](https://matplotlib.org/stable/api/matplotlib_configuration_api.html) можна ознайомитись з усіма можливими командами.\n\nРозглянемо можливість використання всіх згаданих показників у якості індикаторів або індикаторів-передвісників кризових явищ. Для прикладу завантажимо часовий ряд Біткоїна за період з 1 вересня 2015 по 1 березня 2020, використовуючи `yfinance`:\n\n::: {.callout-important}\n## Важливо\n\nПредставлені в подальшому методи є універсальними. Іншими словами, ви можете їх використовувати не лише для фінансових часових рядів, але й для біологічних, фізичних та інших систем, що існують в осяжній нами реальності та можуть бути репрезентовані у вигляду часового ряду. Може бути так, що наявні у вас дані, наприклад, представлені у форматі текстового документа (.txt). Нижче представлено приклад зчитування текстового файлу, що представляє залежність між напруженням і деформацією твердого тіла. Представлену далі залежність було отримано в результаті механічних випробувань певного металу. Зрозуміло, що аналіз результатів і висновки у цьому випадку залежать від того, з яким рядом ми працюємо\n\n:::\n\n---\n\nТепер виведемо значення, що були зчитані з текстового документа:\n\nДля даного ряду, за потребою, можна виконувати подальші розрахунки.\n\n---\n\n::: {.callout-warning}\n## Увага\n\nЗнову повертаємось до Біткоїна. Для відтворення подальших розрахунків з Біткоїном блок коду в якому зчитувалась та виводилась крива \"напруга-видовження\" треба проігнорувати  \n\n:::\n\nВиведемо значення Біткоїна:\n\nВидно, що ряд нестаціонарний, що викликає певні ускладнення для подальшого аналізу. Тому перейдемо до прибутковостей, які вже є стаціонарними, а нормалізація стандартним відхиленням дозволяє легко порівнювати їх розподіл з розподілом Гауса.\n\nПрибутковості розраховуватимуться згідно рівняння ([-@eq-1-1]). У Python для цього ми використовуватимемо метод `pct_change()`, що доступний нам завдяки бібліотеці `pandas`.\n\nСтандартизовані прибутковості можна визначити як $g(t) = \\left[G(t) - \\mu \\right] / \\sigma$, де $\\mu$ відповідає середньому значенню прибутковостей за досліджуваний часовий інтервал, а $\\sigma$ представляє стандартне відхилення.\n\nВиводимо отриманий результат:\n\nЗверніть увагу, що флуктуації нормалізованих прибутковостей досить часто перевищують величину $\\pm 3\\sigma$, що, як відомо, надзвичайно рідко спостерігається для незалежних подій. Цей факт можна відобразити шляхом порівняння функції розподілу нормалізованих флуктуацій з розподілом Гауса (@fig-btc-dist). Очевидно, що хвости розподілу вихідного ряду містять значні флуктуації, вони досить помітні (часто кажуть \"важкі\" у порівнянні з самою \"головою\" розподілу).  \n\nДля побудови нормального розподілу скористаємось бібліотекою `scipy`. Встановити її можна за аналогією з попередніми бібліотеками.\n\nФункція щільності ймовірності `norm` для дійсних значень $x$ має наступний вигляд: $f(x) = \\exp{(-x^2/2)} \\big/ \\sqrt{2\\pi}$.\n\nЯк ми можемо бачити, крива Гауса відхиляється від істинної частоти настання подій, що перевищують $\\pm 3\\sigma$, і ми можемо стверджувати, що прибутковості не є незалежними. Підтвердження цьому факту будемо шукати шляхом вивчення кореляційних властивостей нашого часового ряду.\n\nДля простоти обчислень скористаємось функцією `signal_autocor()` бібліотеки `neurokit2`. Виглядає дана функція наступним чином:\n\n**`signal_autocor(signal, lag=None, demean=True, method='auto', show=False)`**\n\n**Параметри:**\n\n- **signal** (*Union[list, np.array, pd.Series]*) --- вектор значень;\n- **lag** (*int*) --- часовий лаг. Якщо вказано, буде повернуто одне значення автокореляції сигналу з його власним лагом;\n- **demean** (*bool*) --- якщо має значення `True`, від сигналу буде відніматися середнє значення сигналу перед обчисленням автокореляції;\n- **method** (*str*) --- використання `\"auto\"` запускає `scipy.signal.correlate` швидшого алгоритму. Інші методи зберігаються з причин застарілості, але не рекомендуються. Вони включають `\"correlation\"` (за допомогою `np.correlate()`) або `\"fft\"` (швидке перетворення Фур'є);\n- **show** (*bool*) --- якщо значення `True`, побудувати графік автокореляції для всіх значень затримки.\n\n**Повертає:**\n\n- **r** (*float*) --- крос-кореляція сигналу із самим собою на різних часових лагах. Мінімальний часовий лаг дорівнює 0, максимальний часовий лаг дорівнює довжині сигналу. Або значення кореляції на певному часовому лазі, якщо лаг не дорівнює `None`;\n- **info** (*dict*) --- cловник, що містить додаткову інформацію, наприклад, довірчий інтервал.\n\nАле, досліджуючи складні системи, варто пам'ятати, що їх складність є варіативною. Тому і внутрішні кореляції системи на різних часових лагах також варіюються з плином часу. Із цього випливає, що подальщі розрахунки варто виконувати не для всього ряду, а для його фрагментів.\n\nСформулюємо алгоритм **ковзного (рухомого) вікна**. Виділимо  фрагмент часового ряду (вікно), розрахуємо необхідні міри складності, змістимо вікно вздовж часового ряду на заздалегідь визначену величину (крок) і повторимо процедуру до вичерпання часового ряду. Далі, порівнюючи динаміку фактичного часового ряду і відповідних мір складності, ми матимемо змогу судити про характерні зміни в динаміці міри складності зі зміною досліджуваної системи. Якщо та чи інша міра складності поводиться характерним чином для всіх особливих періодів (наприклад, крахів), зменшується або збільшується у передкризовий період, то вона може служити їх індикатором або передвісником.\n\nРозглянемо як поводитиме себе функція автокореляцій та волатильність в рамках алгоритму ковзного вікна.\n\nСпочатку визначимо параметри:\n\nДалі розпочнемо розрахунки. Для відслідковування прогресу зміщення ковзного вікна скористаємось бібліотекою `tqdm`. Її можна встановити аналогічно попереднім бібліотекам:\n\nІмпортуємо модуль для візуалізації прогресу:\n\nІ тепер приступимо до виконання віконної процедури:\n\nЗбережемо результати в окремих текстових файлах:\n\nНарешті, порівняємо динаміку вихідного ряду і розрахованих похідних. Для цього врахуємо, що автокореляцію і волатильність ми знаходили для рухомого вікна. Результати представлено на @fig-btc-all.\n\nАналізуючи графік, можна зробити висновок, що у певні моменти спостерігалися стрибки волатильності (як і автокореляції) із поступовим зменшенням її до попереднього рівня, що може бути наслідком збурень у процесі роботи ринку. Аналіз таких збурень, їх частоти та сили, дозволяє виявляти приховані закономірності роботи ринку.\n\n## Висновок\n\nТаким чином, аналіз флуктуацій прибутковостей та волатильностей шляхом побудови функції автокореляції та розподілу ймовірності дозволяє отримати певні висновки, що можуть допомогти в роботі із аналізованими часовими рядами і ринком, з якого взято зазначені часові ряди. Зокрема, у даному випадку, можна надавати корисні рекомендації фінансовим аналітикам.\n\n## Завдання для самостійної роботи\n\n1. Отримати індекс часового ряду у викладача\n2. Провести дослідження згідно інструкції\n3. Дослідити зміни розрахованих величин для вікон 100 і 500, з кроком 1. Порівняти результати\n4. Зробити висновки\n\n## Контрольні питання\n\n1. Порівняйте вид залежностей флуктуацій цін і прибутковостей. Чому при розрахунках користуються не цінами, а прибутковостями?\n2. Яку характеристику ряду визначає волатильність?\n3. У чому причина різних залежностей для прибутковостей та їх модулів?\n\n## Додаток\n\nДля обрання часового індексу часового ряду використаємо дані, що розміщенні на сайті [Yahoo! Finance](https://finance.yahoo.com). Оскільки окремі фінансові показники не завжди є доступними, будемо використовувати список компаній, що входять до індексу [DJIA](https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average). За вказаним посиланням та номером у списку групи оберіть компанію, що входить до індексу та проведіть відповідні розрахунки. Порівняйте отримані результати з такими ж для Біткоїна.\n","srcMarkdownNoYaml":"\n\n\n\n\n**Тема.** Аналіз флуктуацій часового ряду\n\n**Мета.** Навчитися використовувати аналіз флуктуацій та його похідні для отримання нелінійних характеристик часового ряду\n\n\n\n## Теоретичні відомості\n\n### Аналіз динаміки прибутків, модулів прибутків та волатильностей\n\nОстаннім часом вчені все більше цікавляться економічними часовими рядами, і відбувається це за кількох причин, зокрема: (1) економічні часові ряди, такі як індекси акцій, курсів валют, залежать від розвитку великої кількості взаємодіючих систем, і є прикладами складних систем, що широко вивчаються у науці; (2) з'явилась велика кількість доступних баз з даними про економічні системи, що містять інформацію з різними часовими шкалами (починаючи з 1 хвилини і закінчуючи 1 роком). Внаслідок цього вже на даний час існує також велика кількість розроблених методів (зокрема, у статистичній фізиці), спрямованих на отримання характеристик цін акцій чи курсів валют, що еволюціонують у часі.\n\nДослідження, проведені над часовими рядами, показують, що стохастичний процес, який лежить у основі зміни ціни, характеризується кількома ознаками. Розподіл зміни ціни має виділений хвіст порівняно із Гаусовим розподілом. Функція автокореляції зміни ціни спадає експоненційно з певним характерним часом. Однак, виявляється, що амплітуда зміни ціни, виміряна за абсолютними значеннями чи квадратами цін, показує степеневі кореляції з довго часовою персистентністю аж до кількох місяців, або навіть років. Такі довгочасові залежності краще моделюються з використанням \"додаткового процесу\", що в економічній літературі часто називається **волатильністю**. Волатильність змін ціни акції є мірою того, як сильно ринок схильний до флуктуацій, тобто відхилень ціни від попередніх значень.\n\nПершим кроком при проведенні аналізу є побудова оцінювача волатильності. Ми будемо отримувати волатильність як локальне середнє модуля зміни ціни.\n\nРозуміння статистичних властивостей волатильності має також важливе практичне застосування. Волатильність є інтересом торговців, оскільки визначає ризик і є ключовим входом практично до всіх моделей цін опціонів (вторинного цінного паперу), включаючи і класичну модель Блека-Шоулза. Без задовільних методів оцінювання волатильності трейдерам було б надзвичайно важко визначати ситуації, в яких опціони попадають в недооцінку чи переоцінку.\n\n### Визначення волатильності\n\nТермін волатильність представляє узагальнену міру величини ринкових флуктуацій (відхилень). У літературі існує досить багато визначень волатильності, проте ми будемо використовувати наступне: *волатильність є локальним середнім модуля зміни ціни на відповідному часовому інтервалі $T$, що є рухомим параметром нашої оцінки*. Для індексу $X(t)$ визначимо зміну ціни $G(t)$ як зміну логарифмів індексів,\n\n$$\nG(t) = \\ln{X(t+\\Delta t) - \\ln{X(t)}} \\cong \\left[ X(t+\\Delta t) - X(t) \\right] \\big/ X(t),\n$$ {#eq-1-1}\n\nде $\\Delta t$ є часовим інтервалом затримки. Величину ([-@eq-1-1]) називають прибутковістю (return). Якщо використовувати границі, то малі зміни $X(t)$ приблизно відповідають змінам, визначеним другою рівністю. Ми лише підраховуємо час роботи ринку, викидаємо ночі, вихідні та свята із набору даних, тобто, вважаємо, що ринок працює без перерв.\n\nМодуль $G(t)$ описує амплітуду флуктуацій. У порівнянні зі значеннями $G(t)$ їх модуль не показує глобальних трендів, але великі значення $G(t)$ відповідають крахам та великим миттєвим змінам на ринках.\n\nВизначимо волатильність як середнє від $G(t)$ для часових вікон $T = n \\cdot \\Delta t$, тобто\n\n$$\nV_{T} = \\frac{1}{n}\\sum_{t^{'}=t}^{t+n-1}\\left| G(t^{'}) \\right|,\n$$ {#eq-1-2}\n\nде $n$ є цілим числом. Таке визначення може бути ще узагальнене заміною $G(t)$ на $\\left| G(t) \\right|^{\\gamma}$, де $\\gamma > 1$ дає більш виражені великі значення $G(t)$, в той час як $0 < \\gamma < 1$ виділяє малі значення $G(t)$.\n\nУ цьому визначенні волатильності використовується два параметри: $\\Delta t$ та $n$. Параметр $n$ є шаблонним (чи модельним) часовим інтервалом для даних, а параметр $\\Delta t$ є кроком переміщення часового вікна. Зауважимо, що вказане визначення волатильності має внутрішню помилку, а саме: вибір більшого часового інтервалу $T$ веде до збільшення точності визначення волатильності. Однак, велике значення $T$ також включає погане розбиття часу на інтервали, що веде, у свою чергу, до врахування не всієї прихованої у ряді інформації.\n\n### Визначення кореляцій\n\nДля визначення кореляцій часового ряду використовується функція **автокореляції**. Саме поняття *автокореляції* означає кореляцію часового ряду самого з собою (між попередніми та наступними значеннями). Автокореляцію іноді називають *послідовною кореляцією*, що означає кореляцію між членами ряду чисел, розташованих у певному порядку. Також синонімами цього терміну є *лагова кореляція* та *персистентність*. Наприклад, часто зустрічається автокореляція геофізичних процесів, що означає перенесення залишкового процесу на наступні часові проміжки.\n\nПозитивно автокорельований часовий ряд часто називають персистентним, що значить існування тенденції слідування великих значень за великими та малих за малими, інакше позитивно корельований часовий ряд можна назвати інертним.\n\nВізьмемо $N$ пар спостережень двох змінних $x$ та $y$. Коефіцієнт кореляції між парами $x$ та $y$ визначається як\n\n$$\nr = \\left[ \\sum \\left( x_i - \\bar{x} \\right) \\left( y_i - \\bar{y} \\right) \\right] \\Bigg/ \\left[ \\sqrt{\\sum \\left( x_i - \\bar{x} \\right)^{2}} \\sqrt{\\sum \\left( y_i - \\bar{y} \\right)^{2}} \\right],\n$$ {#eq-1-3}\n\nде сума знаходиться за всіма $N$ спостереженням.\n\nТаким же чином можна визначати й автокореляцію, або ж кореляцію всередині досліджуваного часового ряду. Для автокореляції першого порядку береться лаг (часова затримка), рівний 1 часовій одиниці. Отже, автокореляція першого порядку використовує перші $N−1$ спостережень $x_t, t = 1,..., N−1$ та наступні $N−1$ спостережень $x_t , t = 2,..., N$.\n\nКореляція між $x_t$ та $x_t + 1$ визначається як\n\n$$\nr_1 = \\left[ \\sum_{t=1}^{N-1} \\left( x_t - \\bar{x} \\right) \\left( x_{t+1} - \\bar{x} \\right) \\right] \\Bigg/ \\left[ \\sum_{t=1}^{N}\\left( x_t - \\bar{x} \\right)^2 \\right],\n$$ {#eq-1-4}\n\nде $x$ --- це середнє для досліджуваного періоду.\n\nРівняння ([-@eq-1-4]) може бути узагальнене для отримання кореляції між спостереженнями, розділеними $k$ часовими інтервалами:\n\n$$\nr_k = \\left[ \\sum_{t=1}^{N-k} \\left( x_t - \\bar{x} \\right) \\left( x_{t+k} - \\bar{x} \\right) \\right] \\Bigg/ \\left[ \\sum_{t=1}^{N}\\left( x_t - \\bar{x} \\right)^2 \\right].\n$$ {#eq-5}\n\nЗначення $r_k$ називається коефіцієнтом автокореляції з лагом $k$. Графік функції автокореляції як залежності $r_k$ від $k$ також називають корелограмою.\n\n## Хід роботи\n\nДля подальшої роботи з моделювання складних систем візьмемо з основу бібліотеку `yfinance`, що дозволяє працювати з даними фінансових ринків засобами мови програмування Python.\n\n:::{.callout-note}\n## Примітка\n\n**Yahoo!, Y!Finance, and Yahoo! finance є зареєстрованими товарними знаками Yahoo, Inc.**\n\n`yfinance` не є афілійованим, схваленим або перевіреним Yahoo, Inc. Це інструмент з відкритим вихідним кодом, який використовує загальнодоступні API Yahoo, і призначений для дослідницьких та освітніх цілей.\n\nВи повинні звернутися до умов використання Yahoo! ([сюди](https://policies.yahoo.com/us/en/yahoo/terms/product-atos/apiforydn/index.htm), [сюди](https://legal.yahoo.com/us/en/yahoo/terms/otos/index.html) і [сюди](https://policies.yahoo.com/us/en/yahoo/terms/index.htm)) для отримання детальної інформації про ваші права на використання фактично завантажених даних. Пам'ятайте --- фінансовий API Yahoo! призначений лише для особистого використання\n\n:::\n\nДля встановлення бібліотеки `yfinance` можете скористатися наступною командою:\n\n[Гітхаб репозиторій](https://github.com/ranaroussi/yfinance) містить більше інформації по самій бібліотеці та помилкам, що можуть виникнути та їх потенційним рішенням.  \n\n### Вступ до модуля `Ticker()`\n\nПерш за все імпортуємо бібліотеку `yfinance` за допомогою наступної команди:\n\nМодуль `Ticker()` дозволяє отримувати ринкові та метадані для цінного паперу, використовуючи Python:\n\nМожна вилучити всю інформацію по досліджуваному індексу:\n\nМожна вилучити ринкові значення за максимальний період часу:\n\nОкрім цього, `yfinance` дозволяє отримати інформацію по дивідентам та сплітам фінансового індексу:\n\nДля методу `history()` доступні аргументи:\n\n- **period**: період даних для завантаження (або використовуйте параметр period, або використовуйте start і end). Допустимі періоди: 1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max;\n- **interval**: інтервал даних (внутрішньоденні дані не можуть перевищувати 60 днів) Допустимі інтервали 1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h, 1d, 5d, 1wk, 1mo, 3mo;\n- **start**: Якщо не використовується період --- завантажте рядок дати початку у форматі (YYYY-MM-DD) або *datetime*;\n- **end**: Якщо не використовується період --- завантажте рядок дати закінчення (YYYY-MM-DD) або *datetime*;\n- **prepost**: Включати в результати попередні та пост ринкові дані (За замовчуванням False);\n- **auto_adjust**: Автоматично налаштовувати всі OHLC (ціни відкриття, закриття, найбільшу та найменшу) (За замовчуванням True);\n- **actions**: Завантажувати події дивідендів та дроблення акцій (За замовчуванням True).\n\n### Одночасне вивантаження декількох ринкових активів\n\nЯк і до цього, ви також можете завантажувати дані для кількох тикерів одночасно:\n\nДля отримання конкретно цін закриття індексу **SPY** вам варто використовувати наступну команду: `data['Close']['SPY']`\nАле, якщо вам необхідно згрупувати дані за їх символом, можна скористатися наступним записом:\n\nТепер для звернення до цін закриття індексу **SPY** вам треба використовувати наступний запис: `data['SPY']['Close']`.\n\nМетод `download()` приймає додатковий параметр `threads` для швидшої обробки великої кількості фінансових індексів одночасно.\n\nДля подальшої роботи нас ще будуть цікавати наступні бібліотеки:\n\n- **`matplotlib`**: комплексна бібліотека для створення статичних, анімованих та інтерактивних візуалізацій на Python. Matplotlib робить прості речі простими, а складні --- можливими;\n- **`pandas`**: програмна бібліотека написана для мови програмування Python для маніпулювання та аналізу даних. Зокрема, вона пропонує структури даних та операції з числовими таблицями та часовими рядами;\n- **`numpy`**: бібліотека, що додає підтримку великих багатовимірних масивів і матриць, а також колекцію високорівневих математичних функцій для роботи з цими масивами;\n- **`neurokit2`**: зручна бібліотека, що забезпечує легкий доступ до розширених процедур обробки біосигналів. Дослідники та клініцисти без глибоких знань програмування або біомедичної обробки сигналів можуть аналізувати фізіологічні дані за допомогою лише двох рядків коду. Перевага даної бібліотеки полягає в тому, що вона надає функціонал, який можна використовувати не лише для біомедичних сигналів, але й для фінансових, фізичних тощо.\n\n\nВстановити кожну з даних бібліотек можна в наступний спосіб: `!pip install *назва бібліотеки*`:\n\nДалі нам треба буде визначити стиль рисунків для виведення та збереження. Встановимо наступну бібліотеку:\n\nІмпортуємо кожну із зазначених бібліотек:\n\nВиконаємо налаштування стилю наших подальших рисунків:\n\nПредставлені налаштування є орієнтовними і можуть змінюватись у ході наступних лабораторних роботах. Ви можете встановлювати власні налаштування. На сайті бібліотеки [matplotlib](https://matplotlib.org/stable/api/matplotlib_configuration_api.html) можна ознайомитись з усіма можливими командами.\n\nРозглянемо можливість використання всіх згаданих показників у якості індикаторів або індикаторів-передвісників кризових явищ. Для прикладу завантажимо часовий ряд Біткоїна за період з 1 вересня 2015 по 1 березня 2020, використовуючи `yfinance`:\n\n::: {.callout-important}\n## Важливо\n\nПредставлені в подальшому методи є універсальними. Іншими словами, ви можете їх використовувати не лише для фінансових часових рядів, але й для біологічних, фізичних та інших систем, що існують в осяжній нами реальності та можуть бути репрезентовані у вигляду часового ряду. Може бути так, що наявні у вас дані, наприклад, представлені у форматі текстового документа (.txt). Нижче представлено приклад зчитування текстового файлу, що представляє залежність між напруженням і деформацією твердого тіла. Представлену далі залежність було отримано в результаті механічних випробувань певного металу. Зрозуміло, що аналіз результатів і висновки у цьому випадку залежать від того, з яким рядом ми працюємо\n\n:::\n\n---\n\nТепер виведемо значення, що були зчитані з текстового документа:\n\nДля даного ряду, за потребою, можна виконувати подальші розрахунки.\n\n---\n\n::: {.callout-warning}\n## Увага\n\nЗнову повертаємось до Біткоїна. Для відтворення подальших розрахунків з Біткоїном блок коду в якому зчитувалась та виводилась крива \"напруга-видовження\" треба проігнорувати  \n\n:::\n\nВиведемо значення Біткоїна:\n\nВидно, що ряд нестаціонарний, що викликає певні ускладнення для подальшого аналізу. Тому перейдемо до прибутковостей, які вже є стаціонарними, а нормалізація стандартним відхиленням дозволяє легко порівнювати їх розподіл з розподілом Гауса.\n\nПрибутковості розраховуватимуться згідно рівняння ([-@eq-1-1]). У Python для цього ми використовуватимемо метод `pct_change()`, що доступний нам завдяки бібліотеці `pandas`.\n\nСтандартизовані прибутковості можна визначити як $g(t) = \\left[G(t) - \\mu \\right] / \\sigma$, де $\\mu$ відповідає середньому значенню прибутковостей за досліджуваний часовий інтервал, а $\\sigma$ представляє стандартне відхилення.\n\nВиводимо отриманий результат:\n\nЗверніть увагу, що флуктуації нормалізованих прибутковостей досить часто перевищують величину $\\pm 3\\sigma$, що, як відомо, надзвичайно рідко спостерігається для незалежних подій. Цей факт можна відобразити шляхом порівняння функції розподілу нормалізованих флуктуацій з розподілом Гауса (@fig-btc-dist). Очевидно, що хвости розподілу вихідного ряду містять значні флуктуації, вони досить помітні (часто кажуть \"важкі\" у порівнянні з самою \"головою\" розподілу).  \n\nДля побудови нормального розподілу скористаємось бібліотекою `scipy`. Встановити її можна за аналогією з попередніми бібліотеками.\n\nФункція щільності ймовірності `norm` для дійсних значень $x$ має наступний вигляд: $f(x) = \\exp{(-x^2/2)} \\big/ \\sqrt{2\\pi}$.\n\nЯк ми можемо бачити, крива Гауса відхиляється від істинної частоти настання подій, що перевищують $\\pm 3\\sigma$, і ми можемо стверджувати, що прибутковості не є незалежними. Підтвердження цьому факту будемо шукати шляхом вивчення кореляційних властивостей нашого часового ряду.\n\nДля простоти обчислень скористаємось функцією `signal_autocor()` бібліотеки `neurokit2`. Виглядає дана функція наступним чином:\n\n**`signal_autocor(signal, lag=None, demean=True, method='auto', show=False)`**\n\n**Параметри:**\n\n- **signal** (*Union[list, np.array, pd.Series]*) --- вектор значень;\n- **lag** (*int*) --- часовий лаг. Якщо вказано, буде повернуто одне значення автокореляції сигналу з його власним лагом;\n- **demean** (*bool*) --- якщо має значення `True`, від сигналу буде відніматися середнє значення сигналу перед обчисленням автокореляції;\n- **method** (*str*) --- використання `\"auto\"` запускає `scipy.signal.correlate` швидшого алгоритму. Інші методи зберігаються з причин застарілості, але не рекомендуються. Вони включають `\"correlation\"` (за допомогою `np.correlate()`) або `\"fft\"` (швидке перетворення Фур'є);\n- **show** (*bool*) --- якщо значення `True`, побудувати графік автокореляції для всіх значень затримки.\n\n**Повертає:**\n\n- **r** (*float*) --- крос-кореляція сигналу із самим собою на різних часових лагах. Мінімальний часовий лаг дорівнює 0, максимальний часовий лаг дорівнює довжині сигналу. Або значення кореляції на певному часовому лазі, якщо лаг не дорівнює `None`;\n- **info** (*dict*) --- cловник, що містить додаткову інформацію, наприклад, довірчий інтервал.\n\nАле, досліджуючи складні системи, варто пам'ятати, що їх складність є варіативною. Тому і внутрішні кореляції системи на різних часових лагах також варіюються з плином часу. Із цього випливає, що подальщі розрахунки варто виконувати не для всього ряду, а для його фрагментів.\n\nСформулюємо алгоритм **ковзного (рухомого) вікна**. Виділимо  фрагмент часового ряду (вікно), розрахуємо необхідні міри складності, змістимо вікно вздовж часового ряду на заздалегідь визначену величину (крок) і повторимо процедуру до вичерпання часового ряду. Далі, порівнюючи динаміку фактичного часового ряду і відповідних мір складності, ми матимемо змогу судити про характерні зміни в динаміці міри складності зі зміною досліджуваної системи. Якщо та чи інша міра складності поводиться характерним чином для всіх особливих періодів (наприклад, крахів), зменшується або збільшується у передкризовий період, то вона може служити їх індикатором або передвісником.\n\nРозглянемо як поводитиме себе функція автокореляцій та волатильність в рамках алгоритму ковзного вікна.\n\nСпочатку визначимо параметри:\n\nДалі розпочнемо розрахунки. Для відслідковування прогресу зміщення ковзного вікна скористаємось бібліотекою `tqdm`. Її можна встановити аналогічно попереднім бібліотекам:\n\nІмпортуємо модуль для візуалізації прогресу:\n\nІ тепер приступимо до виконання віконної процедури:\n\nЗбережемо результати в окремих текстових файлах:\n\nНарешті, порівняємо динаміку вихідного ряду і розрахованих похідних. Для цього врахуємо, що автокореляцію і волатильність ми знаходили для рухомого вікна. Результати представлено на @fig-btc-all.\n\nАналізуючи графік, можна зробити висновок, що у певні моменти спостерігалися стрибки волатильності (як і автокореляції) із поступовим зменшенням її до попереднього рівня, що може бути наслідком збурень у процесі роботи ринку. Аналіз таких збурень, їх частоти та сили, дозволяє виявляти приховані закономірності роботи ринку.\n\n## Висновок\n\nТаким чином, аналіз флуктуацій прибутковостей та волатильностей шляхом побудови функції автокореляції та розподілу ймовірності дозволяє отримати певні висновки, що можуть допомогти в роботі із аналізованими часовими рядами і ринком, з якого взято зазначені часові ряди. Зокрема, у даному випадку, можна надавати корисні рекомендації фінансовим аналітикам.\n\n## Завдання для самостійної роботи\n\n1. Отримати індекс часового ряду у викладача\n2. Провести дослідження згідно інструкції\n3. Дослідити зміни розрахованих величин для вікон 100 і 500, з кроком 1. Порівняти результати\n4. Зробити висновки\n\n## Контрольні питання\n\n1. Порівняйте вид залежностей флуктуацій цін і прибутковостей. Чому при розрахунках користуються не цінами, а прибутковостями?\n2. Яку характеристику ряду визначає волатильність?\n3. У чому причина різних залежностей для прибутковостей та їх модулів?\n\n## Додаток\n\nДля обрання часового індексу часового ряду використаємо дані, що розміщенні на сайті [Yahoo! Finance](https://finance.yahoo.com). Оскільки окремі фінансові показники не завжди є доступними, будемо використовувати список компаній, що входять до індексу [DJIA](https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average). За вказаним посиланням та номером у списку групи оберіть компанію, що входить до індексу та проведіть відповідні розрахунки. Порівняйте отримані результати з такими ж для Біткоїна.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"highlight-style":"arrow","css":["style.css"],"output-file":"lab_1.html"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-text-placeholder":"","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","bibliography":["references_main.bib"],"csl":"physical-review-b.csl","callout-appearance":"default","grid":{"body-width":"1050px"},"page-layout":"full","theme":{"light":"cosmo","dark":"superhero"},"title":"Лабораторна робота № 1"},"extensions":{"book":{"multiFile":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","toc":true,"number-sections":true,"output-file":"lab_1.docx"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-text-placeholder":"","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів","listing-page-words":"{0} words"},"metadata":{"bibliography":["references_main.bib"],"csl":"physical-review-b.csl","callout-appearance":"default","fontsize":14,"title":"Лабораторна робота № 1"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","docx"]}