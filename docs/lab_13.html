<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Моделювання складних систем у Python - 13&nbsp; Лабораторна робота № 13</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./lab_14.html" rel="next">
<link href="./lab_12.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Пошук не дав результату",
    "search-matching-documents-text": "Результати пошуку",
    "search-copy-link-title": "Скопіюйте посилання для пошуку",
    "search-hide-matches-text": "Приховати додаткові результати",
    "search-more-match-text": "Додатковий результат у цьому документі",
    "search-more-matches-text": "Додаткові результати у цьому документі",
    "search-clear-button-title": "Очистити",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Скасувати",
    "search-submit-button-title": "Надіслати",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="style.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./lab_13.html"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Лабораторна робота № 13</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Моделювання складних систем у Python</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/Butman2099/Complex-systems-book" title="Вихідний код" class="quarto-navigation-tool px-1" aria-label="Вихідний код"><i class="bi bi-github"></i></a>
    <a href="./Моделювання-складних-систем-у-Python.docx" title="Download Docx" class="quarto-navigation-tool px-1" aria-label="Download Docx"><i class="bi bi-file-word"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Передмова</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Лабораторна робота № 1</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Лабораторна робота № 2</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Лабораторна робота № 3</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Лабораторна робота № 4</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Лабораторна робота № 5</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Лабораторна робота № 6</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Лабораторна робота № 7</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Лабораторна робота № 8</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Лабораторна робота № 9</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Лабораторна робота № 10</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Лабораторна робота № 11</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Лабораторна робота № 12</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_13.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Лабораторна робота № 13</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Лабораторна робота № 14</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Додатки</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Інструкція зі встановлення Anaconda Navigator</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appb.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Вступ до мови програмування Python</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Основи Jupyter Notebook</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Вступ до Google Colab</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Список рекомендованої літератури</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Зміст</h2>
   
  <ul>
  <li><a href="#теоретичні-відомості" id="toc-теоретичні-відомості" class="nav-link active" data-scroll-target="#теоретичні-відомості"><span class="header-section-number">13.1</span> Теоретичні відомості</a>
  <ul class="collapse">
  <li><a href="#networkx" id="toc-networkx" class="nav-link" data-scroll-target="#networkx"><span class="header-section-number">13.1.1</span> NetworkX</a></li>
  <li><a href="#типи-мереж" id="toc-типи-мереж" class="nav-link" data-scroll-target="#типи-мереж"><span class="header-section-number">13.1.2</span> Типи мереж</a></li>
  <li><a href="#імпортуємо-інформацію-про-мережу" id="toc-імпортуємо-інформацію-про-мережу" class="nav-link" data-scroll-target="#імпортуємо-інформацію-про-мережу"><span class="header-section-number">13.1.3</span> Імпортуємо інформацію про мережу</a></li>
  <li><a href="#графостатистичні-показники" id="toc-графостатистичні-показники" class="nav-link" data-scroll-target="#графостатистичні-показники"><span class="header-section-number">13.1.4</span> Графостатистичні показники</a></li>
  <li><a href="#широкомасштабний-опис-мереж" id="toc-широкомасштабний-опис-мереж" class="nav-link" data-scroll-target="#широкомасштабний-опис-мереж"><span class="header-section-number">13.1.5</span> Широкомасштабний опис мереж</a></li>
  </ul></li>
  <li><a href="#хід-роботи" id="toc-хід-роботи" class="nav-link" data-scroll-target="#хід-роботи"><span class="header-section-number">13.2</span> Хід роботи</a>
  <ul class="collapse">
  <li><a href="#спектральні-міри-складності-1" id="toc-спектральні-міри-складності-1" class="nav-link" data-scroll-target="#спектральні-міри-складності-1"><span class="header-section-number">13.2.1</span> Спектральні міри складності</a></li>
  <li><a href="#топологічні-міри" id="toc-топологічні-міри" class="nav-link" data-scroll-target="#топологічні-міри"><span class="header-section-number">13.2.2</span> Топологічні міри</a></li>
  </ul></li>
  <li><a href="#висновок" id="toc-висновок" class="nav-link" data-scroll-target="#висновок"><span class="header-section-number">13.3</span> Висновок</a></li>
  <li><a href="#завдання-для-самостійної-роботи" id="toc-завдання-для-самостійної-роботи" class="nav-link" data-scroll-target="#завдання-для-самостійної-роботи"><span class="header-section-number">13.4</span> Завдання для самостійної роботи</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.dev/Butman2099/Complex-systems-book/blob/main/lab_13.ipynb" class="toc-action"><i class="bi bi-github"></i>Редагувати сторінку</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Лабораторна робота № 13</span></h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<p><strong>Тема.</strong> Найпростіші мережі та мережні міри складності.</p>
<p><strong>Мета.</strong> Навчитися використовувати елементи теорії графів для отримання спектральний і топологічних мір складності.</p>
<section id="теоретичні-відомості" class="level2" data-number="13.1">
<h2 data-number="13.1" class="anchored" data-anchor-id="теоретичні-відомості"><span class="header-section-number">13.1</span> Теоретичні відомості</h2>
<p>Для сучасних складних систем характерна нерегулярність зв’язків і висока чисельність елементів, яка може досягати десятків і сотень тисяч. Таким системам та їх мережним моделям, які володіють нетривіальними топологічними властивостями, найбільше відповідає термін “комплексні”. Комплексною мережею вважається система, яка</p>
<ul>
<li>складається з великої кількості компонентів;</li>
<li>допускає “далекосяжні” зв’язки між компонентами;</li>
<li>володіє великомасштабною (у тому числі просторово-часовою) мінливістю.</li>
</ul>
<p>Дана мережа є графом з досить великою кількістю вузлів різної природи, що характеризуються багатовимірним кортежем ознак і динамічно мінливими зв’язками; розподіл ознак вузлів і характеристик зв’язків може бути описаний ймовірнісною моделлю (багатомірним розподілом).</p>
<p>Основною причиною підвищення актуальності розробок у області теорії і практики комплексних мереж є результати сучасних досліджень реальних комп’ютерних, біологічних і соціальних мереж. Властивості багатьох реальних мереж істотно відрізняються від властивостей класичних випадкових графів з рівноймовірними зв’язками між вузлами, які донедавна розглядалися в якості їх базисного математичного модельного прототипу, і тому побудову їх моделей було запропоновано здійснювати з використанням зв’язних структур і степеневих розподілів.</p>
<p>У теорії комплексних мереж виділяють три основні напрямки:</p>
<ul>
<li>дослідження статистичних властивостей, які характеризують поведінку мереж;</li>
<li>створення моделей мереж;</li>
<li>прогнозування поведінки при зміні структурних властивостей мереж.</li>
</ul>
<p>Комплексні мережі використовуються для моделювання об’єктів і систем, дослідження яких іншими способами (за допомогою спостереження або активного експерименту) недоцільні або неможливі. Комп’ютерні мережі відносяться до мереж, які постійно ростуть і розвиваються. Серед факторів, що впливають на зростання мережі в першу чергу необхідно відзначити розмір або протяжність локальної мережі, яка визначається відстанню між найвіддаленішими станціями, при якій в нормальному режимі роботи вузлів чітко розпізнаються колізії, і кількість об’єднаних у мережу комп’ютерів. Для Інтернет-мереж цей розмір називається діаметром мережі і складає приблизно 1 км відстані, що дозволяє отримати високу швидкість зв’язку та максимально можливий рівень сервісу. При зростанні мережі збільшується кількість колізій, різко падає її корисна пропускна здатність і швидкодія передавання сигналу. Обмеження мережі за довжиною є передумовою вибору структури мережі, розбиття її на окремі частини (сегменти), появи додаткових серверів з новою мережею зв’язків, проблеми генеруються в контексті технологій так званої “останньої милі”. Спостерігається динаміка зростання мережі, своєрідна кластеризація, сервери виступають центрами утворених кластерів, відбувається просторове позиціонування компонент мережі у вигляді чітких ієрархічних структур.</p>
<p>Мережа розглядається як множина сегментів, кожен з яких закінчується точкою розгалуження або кінцевої вершиною мережі. Вершинами мережі є сервери, комутатори й кінцеві користувачі, загальну кількість яких позначимо <span class="math inline">\(N\)</span>. Локальні комп’ютерні мережі є об’єктними прототипами графових структур і тому для їх дослідження застосовують методи теорії графів.</p>
<p>Моделювання мереж із використанням апарата теорії графів є важливим напрямком досліджень дискретної математики. В останні роки зросла зацікавленість дослідників до складних мереж з великою кількістю вузлів, зокрема до комп’ютерних мереж, структура яких нерегулярна, складна і динамічно розвивається в часі. Для таких мереж доводиться генерувати стохастичні графи з величезною кількістю вершин.</p>
<p>У загальному вигляді модель комп’ютерної мережі являє собою випадковий граф, закон взаєморозміщення ребер і вершин для якого задається розподілом ймовірностей.</p>
<p>У даний час найпоширенішими є два основних підходи до моделювання складних мереж:</p>
<ul>
<li>випадкові пуассонівські графи та узагальнені випадкові графи;</li>
<li>модель “тісного світу” Воттса і Строгаца <span class="citation" data-cites="watts1998collective">&nbsp;[<a href="references.html#ref-watts1998collective" role="doc-biblioref">1</a>]</span> та її узагальнення, еволюційна модель зростання мережі Барабаші й Альберт <span class="citation" data-cites="doi:10.1126/science.286.5439.509 RevModPhys.74.47">&nbsp;[<a href="references.html#ref-doi:10.1126/science.286.5439.509" role="doc-biblioref">2</a>,<a href="references.html#ref-RevModPhys.74.47" role="doc-biblioref">3</a>]</span>.</li>
</ul>
<p>Перший передбачає генерацію випадкового графа із заздалегідь відомою кількістю вершин і заданими ймовірнісними властивостями. Його ще називають графом <strong>Ердеша-Реньї</strong> зі сталою кількістю вершин <span class="math inline">\(N\)</span>. Розподіл ступенів вузлів <span class="math inline">\(k\)</span> для цього графа визначається формулою Пуассона <span class="math inline">\(P(k) = \exp^{-\left\langle k \right\rangle} \left\langle k \right\rangle^k / k!\)</span>. Побудова графа здійснюється генеруванням, коли до <span class="math inline">\(N\)</span> відокремлених вершин послідовно додаються ребра, що з’єднують випадковим чином довільні пари вершин. Початково граф складається із сукупності малих вершин, які в процесі генерування з часом розростаються до гігантського кластера зв’язаних між собою вершин, число яких є скінченною частиною загальної кількості <span class="math inline">\(N\)</span>. При генерації постійно зростає ймовірність зв’язування вершин, яка досягає з часом деякого критичного значення. В результаті процесу, який має характер фазового переходу, граф спонтанно розростається до гігантського кластера вершин, пов’язаних між собою, що нагадує конденсацію краплі води в перенасиченій парі.</p>
<p>Модель <strong>Воттса-Строгаца</strong> є комп’ютерною моделлю тісного світу. Її побудова зводиться до наступного: розглядається одновимірний, замкнений у кільце, періодичний ланцюг, який складається із <span class="math inline">\(N\)</span> вершин. Спочатку кожну вершину з’єднують з іншими сусідніми, які знаходяться від неї на відстані, не більшій за <span class="math inline">\(k\)</span>, а потім кожне ребро з певною ймовірністю <span class="math inline">\(m\)</span> перез’єднується з довільною вершиною, що призводить до трансформації регулярного ланцюга у граф тісного світу (<a href="#fig-watts-strogatz" class="quarto-xref">Рис.&nbsp;<span>13.1</span></a>). Оскільки в цій моделі кількість ребер є сталою, а ймовірності реалізації графів — різні, то вона зводиться до канонічного ансамблю графів і описує реально існуючі мережі, топологія яких не є ані цілком регулярною, ані цілком випадковою.</p>
<div id="fig-watts-strogatz" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-watts-strogatz-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Images\lab_13\Watts-Strogatz-model.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-watts-strogatz-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.1: Зростання ступеня випадковості при побудові (Increasing randomness) приводить до трансформації регулярного (Regular) ланцюга у граф тісного світу (Small-world) і далі у випадковий (Random) граф
</figcaption>
</figure>
</div>
<p>Більшість реальних графів підпорядковуються степеневому закону розподілу <span class="math inline">\(P(k)\)</span>. Ці графи побудови мереж описуються моделлю переважного приєднання Барабаші-Альберт. Через далекосяжні взаємодії у системи не існує масштабу зміни характерних величин. Ріст і переважне приєднання є основними механізмами побудови безмасштабних (масштабно-інваріантних) мереж.</p>
<p>Нехай вузол <span class="math inline">\(i\)</span> має <span class="math inline">\(k_i\)</span> зв’язків і він може бути приєднаним (зв’язаним) до інших вузлів <span class="math inline">\(k_i\)</span>. Ймовірність приєднання нового вузла до вузла <span class="math inline">\(i\)</span> залежить від ступеня <span class="math inline">\(k_i\)</span> вузла <span class="math inline">\(i\)</span>. Величину <span class="math inline">\(W(k_i) = k_i/\sum_{j}k_j\)</span> називають <strong>переважним приєднанням</strong> (preferential attachment). Не всі вузли мають однакову кількість зв’язків, тому вони характеризуються функцією розподілу <span class="math inline">\(P(k)\)</span>, що визначає ймовірність того, що випадково вибраний вузол має <span class="math inline">\(k\)</span> зв’язків. Для складних мереж функція <span class="math inline">\(P(k)\)</span> відрізняється від розподілу Пуассона для випадкових графів. Для переважної більшості складних мереж спостерігається степенева залежність <span class="math inline">\(P(k)\propto k^{-\gamma}\)</span>.</p>
<p>Покажемо, яким чином у межах єдиного алгоритму розрахувати і проаналізувати основні <strong>спектральні</strong> і <strong>топологічні</strong> властивості найпростіших графів. Для аналізу мережі досліджують характеристики окремих вузлів (локальні), характеристики мережі в цілому (глобальні) та характеристики мережних підструктур. Числові показники деяких глобальних характеристик мережі можуть бути представлені у вигляді аналітичних узагальнень її локальних характеристик (наприклад — найменше, найбільше, середнє значення локального показника, взяте по всім вузлам). Окрім того, що глобальна характеристика може бути представлена у формі одного числа, це також може бути представлення у вигляді розподілу значень локальної характеристики вузлів по всій мережі.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Примітка
</div>
</div>
<div class="callout-body-container callout-body">
<p>Частина представлених у даній лабораторній ілюстрацій була зроблена із використанням наступної книги <span class="citation" data-cites="platt2019network">&nbsp;[<a href="references.html#ref-platt2019network" role="doc-biblioref">4</a>]</span>. Також у відкритому доступі наявні вихідні коди програм даної книги: <a href="https://github.com/PacktPublishing/Network-Science-with-Python-and-NetworkX-Quick-Start-Guide">https://github.com/PacktPublishing/Network-Science-with-Python-and-NetworkX-Quick-Start-Guide</a></p>
</div>
</div>
<section id="networkx" class="level3" data-number="13.1.1">
<h3 data-number="13.1.1" class="anchored" data-anchor-id="networkx"><span class="header-section-number">13.1.1</span> NetworkX</h3>
<p>Для аналізу складних мереж і їх спектральних і топологічних характеристик можна скористатися бібліотекою <a href="https://networkx.org"><strong>NetworkX</strong></a>.</p>
<p>NetworkX дозволяє моделювати, аналізувати та візуалізувати мережі різної природи та складності. Пакет надає класи для представлення декількох типів мереж та реалізацію багатьох алгоритмів, що використовуються в мережній науці. NetworkX відносно простий у встановленні та використанні і має багато вбудованих функцій, тому він ідеально підходить для аналізу мереж різної природи та складності.</p>
<p>NetworkX є безкоштовним програмним забезпеченням з відкритим вихідним кодом. Це означає, що вихідний код доступний для читання, модифікації та розповсюдження (за певних умов). Сам код доступний за адресою <a href="https://github.com/networkx/networkx">https://github.com/networkx/networkx</a>.</p>
<section id="встановлюємо-networkx" class="level4" data-number="13.1.1.1">
<h4 data-number="13.1.1.1" class="anchored" data-anchor-id="встановлюємо-networkx"><span class="header-section-number">13.1.1.1</span> Встановлюємо NetworkX</h4>
<p>Для встановлення даної бібліотеки можна скористатися командою:</p>
<div id="cell-12" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install networkx</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Далі можемо імпортувати відповідні бібліотеки:</p>
<div id="cd74790f" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt <span class="co"># для візуалізації графіків</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np              <span class="co"># для роботи з матрицями</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Пам’ятайте, що оператори <code>import</code> знаходяться у верхній частині вашого коду, вказуючи Python завантажити зовнішній модуль. У цьому випадку ми хочемо завантажити NetworkX, але дамо йому короткий псевдонім <code>nx</code>, оскільки нам доведеться вводити його неодноразово, звідси й інструкція <code>as</code>.</p>
<p>Давайте перевіримо встановлену версію NetworkX. Ми хочемо переконатися, що не використовуємо застарілий пакет.</p>
<div id="68596883" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>nx.__version__</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>'3.1'</code></pre>
</div>
</div>
<p>Далі виконаємо налаштування формату виведення рисунків:</p>
<div id="1e4c8cf1" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>plt.style.use([<span class="st">'science'</span>, <span class="st">'notebook'</span>, <span class="st">'grid'</span>]) <span class="co"># стиль, що використовуватиметься</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                                               <span class="co"># для виведення рисунків</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>params <span class="op">=</span> {</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'figure.figsize'</span>: (<span class="dv">8</span>, <span class="dv">6</span>),            <span class="co"># встановлюємо ширину та висоту рисунків за замовчуванням</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'font.size'</span>: size,                   <span class="co"># розмір фонтів рисунку</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'lines.linewidth'</span>: <span class="dv">2</span>,                <span class="co"># товщина ліній</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'axes.titlesize'</span>: <span class="st">'small'</span>,           <span class="co"># розмір титулки над рисунком</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'axes.labelsize'</span>: size,              <span class="co"># розмір підписів по осям</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'legend.fontsize'</span>: size,             <span class="co"># розмір легенди</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'xtick.labelsize'</span>: size,             <span class="co"># розмір розмітки по осі Ох</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ytick.labelsize'</span>: size,             <span class="co"># розмір розмітки по осі Ох</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"font.family"</span>: <span class="st">"Serif"</span>,              <span class="co"># сімейство стилів підписів </span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"font.serif"</span>: [<span class="st">"Times New Roman"</span>],   <span class="co"># стиль підпису</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'savefig.dpi'</span>: <span class="dv">300</span>,                  <span class="co"># якість збережених зображень</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'axes.grid'</span>: <span class="va">False</span>                   <span class="co"># побудова сітки на самому рисунку</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update(params)              <span class="co"># оновлення стилю згідно налаштувань</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="типи-мереж" class="level3" data-number="13.1.2">
<h3 data-number="13.1.2" class="anchored" data-anchor-id="типи-мереж"><span class="header-section-number">13.1.2</span> Типи мереж</h3>
<p>Почнемо з простих мереж, представлених у NetworkxX класом <code>Graph</code>.</p>
<section id="простий-граф-ненаправлений-та-незважений" class="level4" data-number="13.1.2.1">
<h4 data-number="13.1.2.1" class="anchored" data-anchor-id="простий-граф-ненаправлений-та-незважений"><span class="header-section-number">13.1.2.1</span> Простий граф (ненаправлений та незважений)</h4>
<div id="cell-fig-1" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># "звичайний" граф є неорієнтованим</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.Graph()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># дайте кожній вершині "ім'я", яке у цьому випадку є літерою.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>G.add_node(<span class="st">'a'</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># метод add_nodes_from дозволяє додавати вузли з послідовності, у цьому випадку зі списку</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>nodes_to_add <span class="op">=</span> [<span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>G.add_nodes_from(nodes_to_add)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># додаємо ребро з 'a' в 'b'</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co"># оскільки граф неорієнтовний, то порядок не має значення</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">'a'</span>, <span class="st">'b'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co"># так само як і add_nodes_from, ми можемо додавати ребра з послідовності</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># ребра повинні бути задані як 2-кортежі</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>edges_to_add <span class="op">=</span> [(<span class="st">'a'</span>, <span class="st">'c'</span>), (<span class="st">'b'</span>, <span class="st">'c'</span>), (<span class="st">'c'</span>, <span class="st">'d'</span>)]</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>G.add_edges_from(edges_to_add)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-1-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.2: Найпростійший граф
</figcaption>
</figure>
</div>
</div>
</div>
<p>Існує багато необов’язкових аргументів для функції <code>draw_network()</code>, щоб налаштувати зовнішній вигляд.</p>
<div id="cell-fig-2" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        node_color<span class="op">=</span><span class="st">'blue'</span>,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        node_size<span class="op">=</span><span class="dv">1600</span>,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        font_color<span class="op">=</span><span class="st">'white'</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        font_size<span class="op">=</span><span class="dv">16</span>,</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        )</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-2-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.3: Найпростійший граф із додатковими налаштуваннями фонтів рисунку
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="зважена-мережа" class="level4" data-number="13.1.2.2">
<h4 data-number="13.1.2.2" class="anchored" data-anchor-id="зважена-мережа"><span class="header-section-number">13.1.2.2</span> Зважена мережа</h4>
<p>Повертаючись до випадку неорієнтованих мереж, іноді не всі ребра є рівними. Наприклад, у мережі, що представляє міську систему водопостачання, ребра можуть представляти серію труб, якими вода транспортується з одного місця в інше. Деякі з них можуть мати більшу пропускну здатність, ніж інші. Коли вершини графа можуть мати різну силу зв’язності, мережа називається <strong>зваженою</strong>, а зв’язність кількісно вимірюється числом, яке називається вагою. Зваженими можуть бути як орієнтовані, так і неорієнтовані мережі. При візуалізації мережі вагу ребер часто вказують, змінюючи товщину або непрозорість ребра. Ваги ребер можна використовувати для представлення різних типів атрибутів.</p>
<div id="cell-fig-3" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># зважена мережа</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>G_weighted <span class="op">=</span> nx.Graph()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>G_weighted.add_edge(<span class="st">"A"</span>,<span class="st">"B"</span>,weight<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>G_weighted.add_edge(<span class="st">"A"</span>,<span class="st">"D"</span>,weight<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>G_weighted.add_edge(<span class="st">"A"</span>,<span class="st">"C"</span>,weight<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>G_weighted.add_edge(<span class="st">"B"</span>,<span class="st">"D"</span>,weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_weighted, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-3-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.4: Найпростійший зважений граф
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="направлений-граф" class="level4" data-number="13.1.2.3">
<h4 data-number="13.1.2.3" class="anchored" data-anchor-id="направлений-граф"><span class="header-section-number">13.1.2.3</span> Направлений граф</h4>
<p>Іноді буває корисно додавати трохи більше деталей до мережі. Ребра, які ми бачили попередньо, не враховують звідки одна вершина прямує або куди. Вони просто з’єднують два вузли, тому їх називають <strong>симетричними</strong> або <strong>неорієнтованими</strong>.</p>
<p>Уявіть собі мережу, яка являє собою систему доріг (ребер) і перехресть (вузлів). A мережа з ненаправленими ребрами була б гарним представленням, доки ви не натрапили на вулицю з одностороннім рухом. Ненаправлене ребро припускає, що ви можете рухатися в будь-якому напрямку однаково. Хоча в реальності напрям руху по дорожній смузі матиме значення навіть для вашого життя.</p>
<p>Коли напрямок має значення, мережа називається <strong>орієнтованою (направленою)</strong>. У направленій мережі кожне ребро має вузол-джерело і вузол-приймач. Як правило, ребро представляє якийсь потік, наприклад, трафік, від джерела до цілі. Але що, якщо не всі з’єднання є односторонніми? Двосторонні з’єднання створюються шляхом поєднання двох спрямованих ребер, що йдуть в протилежних напрямках. У спрямованих мережах ребра зображуються стрілками, що вказують на ціль.</p>
<div id="cell-fig-4" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># направлений граф</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>G_di <span class="op">=</span> nx.DiGraph()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>G_di.add_edge(<span class="st">"A"</span>,<span class="st">"B"</span>,weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>G_di.add_edge(<span class="st">"A"</span>,<span class="st">"D"</span>,weight<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>G_di.add_edge(<span class="st">"A"</span>,<span class="st">"C"</span>,weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>G_di.add_edge(<span class="st">"B"</span>,<span class="st">"D"</span>,weight<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co"># створити словник позицій для вузлів</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_di)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_di, pos)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_di, pos)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_labels(G_di, pos)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co"># створити словник міток ребер</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>edge_labels <span class="op">=</span> {(u, v): d[<span class="st">'weight'</span>] <span class="cf">for</span> u, v, d <span class="kw">in</span> G_di.edges(data<span class="op">=</span><span class="va">True</span>)}</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co"># створення міток для ребер</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edge_labels(G_di, pos, edge_labels<span class="op">=</span>edge_labels)<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-4" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-4-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.5: Направлений та зважений граф
</figcaption>
</figure>
</div>
</div>
</div>
<p>Об’єкт граф має деякі властивості та методи, які надають дані про весь граф.</p>
<div id="3362c9e8" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Cписок усіх вузлів</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>G_di.nodes()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>NodeView(('A', 'B', 'D', 'C'))</code></pre>
</div>
</div>
<div id="cell-34" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Список усіх ребер  </span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>G_di.edges()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>OutEdgeView([('A', 'B'), ('A', 'D'), ('A', 'C'), ('B', 'D')])</code></pre>
</div>
</div>
<div id="cell-35" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>G_di.edges(data<span class="op">=</span><span class="va">True</span>) <span class="co"># триплет зі словником (третім йде вага ребра)</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>OutEdgeDataView([('A', 'B', {'weight': 1}), ('A', 'D', {'weight': 3}), ('A', 'C', {'weight': 1}), ('B', 'D', {'weight': 2})])</code></pre>
</div>
</div>
<div id="cell-36" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>G_di.edges[<span class="st">"A"</span>,<span class="st">"B"</span>] <span class="co"># виводимо вагу, вказуючи цікаві для нас вузли напряму. У результаті отримуємо словник</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>{'weight': 1}</code></pre>
</div>
</div>
<div id="cell-37" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>G_di.edges[<span class="st">"A"</span>,<span class="st">"C"</span>][<span class="st">"weight"</span>] <span class="co"># виводимо вагу, вказуючи цікаві для нас вузли напряму. У результаті отримуємо скаляр</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>1</code></pre>
</div>
</div>
<div id="cell-38" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>pos <span class="co"># виводимо словник координат розташувань вузлів на графіку</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>{'A': array([ 0.0080052 , -0.05428409]),
 'B': array([ 0.3455655 , -0.29243526]),
 'D': array([ 0.43837117, -0.65328066]),
 'C': array([-0.79194188,  1.        ])}</code></pre>
</div>
</div>
<p>Об’єкти NodeView та EdgeView мають ітератори, тому ми можемо використовувати їх у циклах <code>for</code>:</p>
<div id="d2f10379" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> G_di.nodes:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(node)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A
B
D
C</code></pre>
</div>
</div>
<div id="504cd342" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> edge <span class="kw">in</span> G_di.edges:</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(edge)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>('A', 'B')
('A', 'D')
('A', 'C')
('B', 'D')</code></pre>
</div>
</div>
<p>Зверніть увагу, що ребра подано у вигляді 2-кортежів, так само, як ми їх ввели.</p>
<p>Ми можемо отримати кількість вершин та ребер у графі за допомогою методів <code>number_of_</code>.</p>
<div id="13c44457" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>G_di.number_of_nodes()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>4</code></pre>
</div>
</div>
<div id="0b3dd214" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>G_di.number_of_edges()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>4</code></pre>
</div>
</div>
<p>Деякі методи роботи з графами приймають ребро або вершину як аргумент. Вони надають властивості графа для даного ребра або вершини. Наприклад, метод <code>.neighbors()</code> повертає вершини, пов’язані з даною вершиною:</p>
<div id="442e390c" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># список сусідів вершини 'A'</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>G_di.neighbors(<span class="st">'A'</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>&lt;dict_keyiterator at 0x2327b03fce0&gt;</code></pre>
</div>
</div>
<p>З міркувань продуктивності багато методів для роботи з графами повертають ітератори замість списків. Їх зручно використовувати у циклах:</p>
<div id="496a886f" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> neighbor <span class="kw">in</span> G_di.neighbors(<span class="st">'A'</span>):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(neighbor)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>B
D
C</code></pre>
</div>
</div>
<p>І ви завжди можете використати конструктор <code>list</code> для створення списку з ітератора:</p>
<div id="c3ea8ddb" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(G_di.neighbors(<span class="st">'A'</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>['B', 'D', 'C']</code></pre>
</div>
</div>
<p>Зверніть увагу на асиметрію в методах роботи з ребрами, таких як <code>has_edge()</code>:</p>
<div id="429101a1" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>G_di.has_edge(<span class="st">'A'</span>, <span class="st">'B'</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>True</code></pre>
</div>
</div>
<div id="454994a6" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>G_di.has_edge(<span class="st">'B'</span>, <span class="st">'A'</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>False</code></pre>
</div>
</div>
<p>Замість симетричного зв’язку “сусіди”, вузли в орієнтованих графах мають <strong>попередників (successors або “in-neighbours”)</strong> і <strong>наступників (predecessors або “out-neighbours”)</strong>:</p>
<div id="ba680e23" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Попередники вершини B:'</span>, <span class="bu">list</span>(G_di.successors(<span class="st">'B'</span>)))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Наступники вершини B:'</span>, <span class="bu">list</span>(G_di.predecessors(<span class="st">'B'</span>)))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Попередники вершини B: ['D']
Наступники вершини B: ['A']</code></pre>
</div>
</div>
<p>Спрямовані графи мають <strong>вхідні ступені вершини</strong> (in-degree) та <strong>вихідні ступені вершини</strong> (out-degree), які показують кількість ребер, що ведуть до та від даної вершини, відповідно:</p>
<div id="a0d80658" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>G_di.in_degree(<span class="st">'A'</span>) <span class="co"># у вершину А не входить жодна вершина (шлях)</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>0</code></pre>
</div>
</div>
<div id="a4dbfbe7" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>G_di.out_degree(<span class="st">'A'</span>) <span class="co"># з вершини А виходять 3 вершини (шляхи)</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>3</code></pre>
</div>
</div>
<p>У NetworkX існує декілька алгоритмів компонування, які можуть бути використані для розміщення вузлів графа при візуалізації, в тому числі</p>
<ol type="1">
<li><p><code>nx.spring_layout()</code>: цей алгоритм використовує примусовий підхід до розміщення вершин. Вузли, які з’єднані ребрами, притягуються один до одного, тоді як вузли, які не з’єднані, відштовхуються. Алгоритм намагається мінімізувати енергію системи, регулюючи положення вузлів.</p></li>
<li><p><code>nx.circular_layout()</code>: алгоритм розміщує вузли рівномірно по колу.</p></li>
<li><p><code>nx.spectral_layout()</code>: даний алгоритм використовує власні вектори матриці суміжності графа для розміщення вершин. Власні вектори використовуються для проектування вершин у простір нижчої розмірності, а положення вершин потім визначаються шляхом оптимізації функції вартості.</p></li>
<li><p><code>nx.random_layout()</code>: вершини розміщуються випадковим чином у заданій обмежувальній області.</p></li>
<li><p><code>nx.shell_layout()</code>: алгоритм фіксує вершини у вигляді концентричних кіл або оболонок, причому вершини в одній і тій же оболонці мають однакову відстань до центру.</p></li>
<li><p><code>nx.kamada_kawai_layout()</code>: використовується ітераційний оптимізаційний підхід для розміщення вузлів. Алгоритм намагається мінімізувати навантаження на систему, змінюючи положення вузлів.</p></li>
<li><p><code>nx.fruchterman_reingold_layout()</code>: варіація алгоритму <code>nx.spring_layout()</code>, і використання силового підходу до розміщення вузлів.</p></li>
</ol>
<p>Кожен алгоритм компонування має свої сильні та слабкі сторони, і вибір найкращого з них залежить від характеристик графа та цілей візуалізації.</p>
</section>
<section id="знакова-мережа" class="level4" data-number="13.1.2.4">
<h4 data-number="13.1.2.4" class="anchored" data-anchor-id="знакова-мережа"><span class="header-section-number">13.1.2.4</span> Знакова мережа</h4>
<div id="cell-fig-5" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>Signed_G <span class="op">=</span> nx.Graph()</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co"># додаємо ребра</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>Signed_G.add_edge(<span class="st">"A"</span>,<span class="st">"B"</span>,sign<span class="op">=</span><span class="st">"*"</span>)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>Signed_G.add_edge(<span class="st">"A"</span>,<span class="st">"C"</span>,sign<span class="op">=</span><span class="st">"-"</span>)</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>Signed_G.add_edge(<span class="st">"A"</span>,<span class="st">"d"</span>,sign<span class="op">=</span><span class="st">"+"</span>)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="co"># вибір алгоритму компонування</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.random_layout(Signed_G)</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="co"># створити словник кольорів ребер на основі знаку кожного ребра</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>edge_colors <span class="op">=</span> {<span class="st">'+'</span>: <span class="st">'green'</span>, <span class="st">'-'</span>: <span class="st">'red'</span>, <span class="st">"*"</span>:<span class="st">"black"</span>}</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [edge_colors[Signed_G[u][v][<span class="st">'sign'</span>]] <span class="cf">for</span> u, v <span class="kw">in</span> Signed_G.edges()]</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a><span class="co"># створити словник стилів ребер на основі знаку кожного ребра</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>edge_styles <span class="op">=</span> {<span class="st">'+'</span>: <span class="st">'solid'</span>, <span class="st">'-'</span>: <span class="st">'dashed'</span>, <span class="st">"*"</span>:<span class="st">"dashed"</span>}</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>styles <span class="op">=</span> [edge_styles[Signed_G[u][v][<span class="st">'sign'</span>]] <span class="cf">for</span> u, v <span class="kw">in</span> Signed_G.edges()]</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф з кольоровими та стилізованими ребрами</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(Signed_G, pos, node_color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(Signed_G, pos, edge_color<span class="op">=</span>colors, style<span class="op">=</span>styles)</span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_labels(Signed_G, pos)<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\Andrii\AppData\Local\Temp\ipykernel_13844\974620191.py:26: DeprecationWarning: `alltrue` is deprecated as of NumPy 1.25.0, and will be removed in NumPy 2.0. Please use `all` instead.
  nx.draw_networkx_edges(Signed_G, pos, edge_color=colors, style=styles)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-5" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-5-output-2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.6: Знакова мережа з налаштуваннями кольорів на основі знаку кожного ребра
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="мультиграф" class="level4" data-number="13.1.2.5">
<h4 data-number="13.1.2.5" class="anchored" data-anchor-id="мультиграф"><span class="header-section-number">13.1.2.5</span> Мультиграф</h4>
<p><strong>Мультиграф</strong> — це тип графа в NetworkX, який допускає декілька ребер між парою вузлів. Іншими словами, <code>MultiGraph</code> може мати паралельні ребра, в той час як стандартний <code>Graph</code> може мати лише одне ребро між будь-якою парою вузлів. Мультиграф — це мережа, в якій декілька ребер можуть з’єднувати одні й ті ж вузли.</p>
<div id="cell-fig-6" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>Multi_G <span class="op">=</span> nx.MultiGraph()</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>Multi_G.add_edge(<span class="st">"A"</span>,<span class="st">"B"</span>,relation<span class="op">=</span><span class="st">"family"</span>,weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>Multi_G.add_edge(<span class="st">"A"</span>,<span class="st">"C"</span>,relation<span class="op">=</span><span class="st">"family"</span>,weight<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>Multi_G.add_edge(<span class="st">"A"</span>,<span class="st">"B"</span>,relation<span class="op">=</span><span class="st">"Work"</span>,weight<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>Multi_G.add_edge(<span class="st">"D"</span>,<span class="st">"B"</span>,relation<span class="op">=</span><span class="st">"Work"</span>,weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>Multi_G.add_edge(<span class="st">"B"</span>,<span class="st">"E"</span>,relation<span class="op">=</span><span class="st">"Friend"</span>,weight<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(Multi_G, with_labels<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-6" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-6-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.7: Зважений мультиграф
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-fig-7" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co"># компонуємо</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(Multi_G)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо вузли</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(Multi_G, pos, node_color<span class="op">=</span><span class="st">'lightblue'</span>, node_size<span class="op">=</span><span class="dv">500</span>)</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо ребра</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>edge_labels <span class="op">=</span> {}</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u, v, d <span class="kw">in</span> Multi_G.edges(data<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (u, v) <span class="kw">in</span> edge_labels:</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>        edge_labels[(u, v)] <span class="op">+=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> d[<span class="st">"relation"</span>] <span class="op">+</span> <span class="st">": "</span> <span class="op">+</span> <span class="bu">str</span>(d[<span class="st">"weight"</span>])</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        edge_labels[(u, v)] <span class="op">=</span> d[<span class="st">"relation"</span>] <span class="op">+</span> <span class="st">": "</span> <span class="op">+</span> <span class="bu">str</span>(d[<span class="st">"weight"</span>])</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edge_labels(Multi_G, pos, edge_labels<span class="op">=</span>edge_labels)</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(Multi_G, pos, width<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо мітки</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_labels(Multi_G, pos, font_size<span class="op">=</span><span class="dv">10</span>, font_family<span class="op">=</span><span class="st">"sans-serif"</span>)<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-7" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-7-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.8: Зважений мультиграф із покращеною візуалізацією
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-66" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ребра</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(Multi_G.edges())</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>[('A', 'B'), ('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E')]</code></pre>
</div>
</div>
<div id="cell-67" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># G.edges(data=True)</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(Multi_G.edges(data<span class="op">=</span><span class="va">True</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>[('A', 'B', {'relation': 'family', 'weight': 1}),
 ('A', 'B', {'relation': 'Work', 'weight': 3}),
 ('A', 'C', {'relation': 'family', 'weight': 2}),
 ('B', 'D', {'relation': 'Work', 'weight': 1}),
 ('B', 'E', {'relation': 'Friend', 'weight': 2})]</code></pre>
</div>
</div>
<div id="cell-68" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># конкретно перелічуючи ребра</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(Multi_G.edges(data<span class="op">=</span><span class="st">"relation"</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>[('A', 'B', 'family'),
 ('A', 'B', 'Work'),
 ('A', 'C', 'family'),
 ('B', 'D', 'Work'),
 ('B', 'E', 'Friend')]</code></pre>
</div>
</div>
<div id="cell-69" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># певне ребро </span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>Multi_G.edges[<span class="st">"A"</span>,<span class="st">"B"</span>] <span class="co"># помилка</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>ValueError: not enough values to unpack (expected 3, got 2)</code></pre>
</div>
</div>
<div id="cell-70" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">#натомість</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co"># атрибути в мультиграфі</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="bu">dict</span>(Multi_G[<span class="st">"A"</span>][<span class="st">"B"</span>])</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>{0: {'relation': 'family', 'weight': 1}, 1: {'relation': 'Work', 'weight': 3}}</code></pre>
</div>
</div>
<div id="cell-71" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(Multi_G.edges(<span class="st">"B"</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>[('B', 'A'), ('B', 'A'), ('B', 'D'), ('B', 'E')]</code></pre>
</div>
</div>
<div id="cell-72" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>Multi_G[<span class="st">"A"</span>][<span class="st">"B"</span>][<span class="dv">0</span>][<span class="st">"relation"</span>]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>'family'</code></pre>
</div>
</div>
</section>
<section id="двочастковий-bipartite-граф" class="level4" data-number="13.1.2.6">
<h4 data-number="13.1.2.6" class="anchored" data-anchor-id="двочастковий-bipartite-граф"><span class="header-section-number">13.1.2.6</span> Двочастковий (bipartite) граф</h4>
<p><strong>Двочастковий граф</strong> — це тип графа, в якому вершини можна розбити на дві непересічні множини так, що всі ребра з’єднують вершину з однієї множини з вершиною в іншій множині. Тобто, не існує ребер, які з’єднують вершини всередині однієї множини.</p>
<p>Двочасткові графи корисні для моделювання відносин між двома різними типами об’єктів, наприклад, покупцями і продавцями на ринку, або акторами і фільмами в кіноіндустрії.</p>
<p>У NetworkX ви можете створювати і маніпулювати двосторонніми графами за допомогою модуля <code>bipartite</code>, який надає різні функції і алгоритми для двосторонніх графів. Крім того, існує декілька методів візуалізації, які можна використовувати для відображення двосторонніх графів, наприклад, двосторонній макет, який розташовує вузли у два окремі рядки.</p>
<p>Приклад акціонерів та акцій:</p>
<div id="cell-fig-8" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx.algorithms <span class="im">import</span> bipartite</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co"># список акціонерів</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>stockholders <span class="op">=</span> [<span class="st">'Alice'</span>, <span class="st">'Bob'</span>, <span class="st">'Charlie'</span>, <span class="st">'David'</span>, <span class="st">'Eve'</span>, <span class="st">'Frank'</span>, <span class="st">'Grace'</span>, <span class="st">'Harry'</span>, <span class="st">'Ivy'</span>, <span class="st">'John'</span>]</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="co"># перелік акцій</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>stocks <span class="op">=</span> [<span class="st">'AAPL'</span>, <span class="st">'GOOG'</span>, <span class="st">'TSLA'</span>, <span class="st">'AMZN'</span>, <span class="st">'FB'</span>, <span class="st">'MSFT'</span>, <span class="st">'NVDA'</span>, <span class="st">'PYPL'</span>, <span class="st">'NFLX'</span>, <span class="st">'TWTR'</span>]</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a><span class="co"># створити двочастковий граф</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> nx.Graph()</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="co"># додавання вузлів зі списку</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>B.add_nodes_from(stockholders, bipartite<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>B.add_nodes_from(stocks, bipartite<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a><span class="co"># додавання ребер випадковим чином</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="kw">not</span> nx.is_connected(B):</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>    B.add_edge(random.choice(stockholders), random.choice(stocks))</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо двочастковий граф</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.bipartite_layout(B, stockholders)</span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(B, pos, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-8" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-8-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.9: Двочасткова мережа акціонерів та їх акцій
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-76" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 2 набори двочасткових графів</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>bipartite.sets(B)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>({'Alice',
  'Bob',
  'Charlie',
  'David',
  'Eve',
  'Frank',
  'Grace',
  'Harry',
  'Ivy',
  'John'},
 {'AAPL',
  'AMZN',
  'FB',
  'GOOG',
  'MSFT',
  'NFLX',
  'NVDA',
  'PYPL',
  'TSLA',
  'TWTR'})</code></pre>
</div>
</div>
<p>Хоча двочасткові графи корисні для представлення повної структури зв’язків “багато-до-багатьох”, іноді простіше працювати зі стандартними односторонніми мережами. Це може бути у випадку, якщо аналіз фокусується на певному типі вузлів, або якщо необхідна методика доступна лише для односторонніх (одномодальних) мереж, або ж методика доступна лише для одномодових мереж, чи мережа зв’язків має занадто багато вузлів для чіткої візуалізації. На щастя, можна створити одномодові мережі з мережі зв’язків за допомогою процесу, який називається “проєкція”.</p>
<p>Одномодові мережі, побудовані з мереж зв’язків, називаються мережами спільної приналежності, тому що вузли з’єднуються ребрами, якщо вони мають спільні зв’язки. Існує кілька типів проекцій, які використовуються для створення спільної приналежності, але всі вони обертаються навколо однієї і тієї ж ідеї: з’єднання вузлів зі спільним сусідом у вихідній мережі приналежності. Найпростіша можлива проекція — це незважена проекція, яка створює незважене ребро між вузлами з одним або декількома спільними сусідами. Наступний код використовує функцію projected_graph() для проектування мережі акціонерів, що мають спільні акції компаній:</p>
<div id="cell-fig-9" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Лівобічний граф (акціонери) </span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co"># акціонери, які мають спільні акції, пов'язані між собою</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Лівобічний граф</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> bipartite.projected_graph(B, bipartite.sets(B)[<span class="dv">0</span>])</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(P, with_labels<span class="op">=</span><span class="va">True</span>, node_size<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-9" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-9-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.10: Лівобічний граф мережі акціонерів у котрих наявні спільні акції
</figcaption>
</figure>
</div>
</div>
</div>
<p>У такий самий спосіб ми можемо побудувати мережу акцій:</p>
<div id="cell-fig-10" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Правобічний граф</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> bipartite.projected_graph(B,bipartite.sets(B)[<span class="dv">1</span>])</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(P, with_labels<span class="op">=</span><span class="va">True</span>, node_size<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-10" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-10-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.11: Лівобічний граф акцій у котрих наявні спільні акціонери
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-fig-11" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Зважений лівобічний граф</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="co"># як багато спільного</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="co"># краща візуалізація</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> bipartite.weighted_projected_graph(B,bipartite.sets(B)[<span class="dv">0</span>])</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.circular_layout(P)</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф </span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(P, pos)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(P, pos)</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_labels(P, pos)</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a><span class="co"># створюємо словник міток ребер</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>edge_labels <span class="op">=</span> {(u, v): d[<span class="st">'weight'</span>] <span class="cf">for</span> u, v, d <span class="kw">in</span> P.edges(data<span class="op">=</span><span class="va">True</span>)}</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо мітки для ребер </span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edge_labels(P, pos, edge_labels<span class="op">=</span>edge_labels)<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-11" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-11-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.12: Лівобічний граф мережі акціонерів, де вагові коефіцієнти на ребрах указують на кількість наявних спільних акцій між акціонерами
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="імпортуємо-інформацію-про-мережу" class="level3" data-number="13.1.3">
<h3 data-number="13.1.3" class="anchored" data-anchor-id="імпортуємо-інформацію-про-мережу"><span class="header-section-number">13.1.3</span> Імпортуємо інформацію про мережу</h3>
<section id="імпортуємо-дані-з-file.txt-та-gexf" class="level4" data-number="13.1.3.1">
<h4 data-number="13.1.3.1" class="anchored" data-anchor-id="імпортуємо-дані-з-file.txt-та-gexf"><span class="header-section-number">13.1.3.1</span> Імпортуємо дані з file.txt та GEXF</h4>
<p>Щоб імпортувати інформацію про мережу до NetworkX, ви можете скористатися однією з декількох функцій, залежно від формату ваших даних. Ось кілька прикладів:</p>
<ol type="1">
<li>Імпорт з файлу списку граней:</li>
</ol>
<p>Припустимо, у вас є файл списку граней, що мають наступне представлення:</p>
<pre><code>A B
A C
B D
C D
D E</code></pre>
<p>Ви можете імпортувати цей файл у граф NetworkX функцією <code>read_edgelist()</code>:</p>
<div id="cell-fig-12" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.read_edgelist(<span class="st">'databases\lab_13\Sample1.txt'</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-12" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-12-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.13: Простий граф, що був зчитаний з текстового файлу за допомогою функції <code>read_edgelist()</code>
</figcaption>
</figure>
</div>
</div>
</div>
<ol start="2" type="1">
<li>Імпорт з файлу матриці суміжності:</li>
</ol>
<p>Припустимо, що у вас є файл матриці суміжності:</p>
<pre><code>0 1 1 0 0
1 0 0 1 0
1 0 0 1 1
0 1 1 0 1
0 0 1 1 0</code></pre>
<p>Ви можете імпортувати цей файл у граф NetworkX за допомогою функції <code>from_numpy_array()</code>:</p>
<div id="cell-fig-13" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>adj_matrix <span class="op">=</span> np.loadtxt(<span class="st">'databases\lab_13\Sample2.txt'</span>)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.from_numpy_array(adj_matrix)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-13" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-13-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.14: Простий граф, що був зчитаний з масиву <code>numpy</code> за допомогою функції <code>from_numpy_array()</code>
</figcaption>
</figure>
</div>
</div>
</div>
<ol start="3" type="1">
<li>Імпорт з файлу GEXF:</li>
</ol>
<p>Якщо у вас є файл мережі у форматі GEXF, який є популярним форматом для обміну даних про графи між різними програмними пакетами, ви можете імпортувати його у граф NetworkX за допомогою функції <code>read_gexf</code>:</p>
<p>Простий граф у форматі GEXF:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode xml code-with-copy"><code class="sourceCode xml"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="fu">&lt;?xml</span><span class="ot"> version=</span><span class="st">"1.0"</span><span class="ot"> encoding=</span><span class="st">"UTF-8"</span><span class="fu">?&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">gexf</span><span class="ot"> xmlns=</span><span class="st">"http://www.gexf.net/1.3"</span><span class="ot"> version=</span><span class="st">"1.3"</span>&gt;</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">meta</span><span class="ot"> lastmodifieddate=</span><span class="st">"2022-10-01"</span>&gt;</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">creator</span>&gt;NetworkX&lt;/<span class="kw">creator</span>&gt;</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">description</span>&gt;An example graph in GEXF format&lt;/<span class="kw">description</span>&gt;</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>  &lt;/<span class="kw">meta</span>&gt;</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">graph</span><span class="ot"> mode=</span><span class="st">"static"</span><span class="ot"> defaultedgetype=</span><span class="st">"undirected"</span>&gt;</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">nodes</span>&gt;</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">node</span><span class="ot"> id=</span><span class="st">"0"</span><span class="ot"> label=</span><span class="st">"Node 0"</span>/&gt;</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">node</span><span class="ot"> id=</span><span class="st">"1"</span><span class="ot"> label=</span><span class="st">"Node 1"</span>/&gt;</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">node</span><span class="ot"> id=</span><span class="st">"2"</span><span class="ot"> label=</span><span class="st">"Node 2"</span>/&gt;</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">nodes</span>&gt;</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">edges</span>&gt;</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">edge</span><span class="ot"> id=</span><span class="st">"0"</span><span class="ot"> source=</span><span class="st">"0"</span><span class="ot"> target=</span><span class="st">"1"</span>/&gt;</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">edge</span><span class="ot"> id=</span><span class="st">"1"</span><span class="ot"> source=</span><span class="st">"1"</span><span class="ot"> target=</span><span class="st">"2"</span>/&gt;</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">edge</span><span class="ot"> id=</span><span class="st">"2"</span><span class="ot"> source=</span><span class="st">"2"</span><span class="ot"> target=</span><span class="st">"0"</span>/&gt;</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">edges</span>&gt;</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>  &lt;/<span class="kw">graph</span>&gt;</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">gexf</span>&gt;</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="cell-fig-14" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.read_gexf(<span class="st">'databases\lab_13</span><span class="ch">\\</span><span class="st">basic.gexf'</span>)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-14" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-14-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.15: Простий граф, що був зчитаний з файлу формату <code>.gexf</code> за допомогою функції <code>read_gexf()</code>
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-91" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Зберігаємо граф у форматі GEXF</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>nx.write_gexf(G, <span class="st">'databases\lab_13\Sample3.gexf'</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="матриця-суміжності" class="level4" data-number="13.1.3.2">
<h4 data-number="13.1.3.2" class="anchored" data-anchor-id="матриця-суміжності"><span class="header-section-number">13.1.3.2</span> Матриця суміжності</h4>
<div id="cell-93" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>G_mat <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]])</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>G_mat</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre><code>array([[0, 1, 1, 1, 0, 1, 0, 0, 0, 0],
       [1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [1, 1, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],
       [1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]])</code></pre>
</div>
</div>
<p>Перетворення матриці суміжності у граф за допомогою <code>nx.Graph</code>:</p>
<div id="cell-fig-15" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.Graph(G_mat)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-15" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-15-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.16: Простий граф, що був побудований напряму з матриці суміжності
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="графостатистичні-показники" class="level3" data-number="13.1.4">
<h3 data-number="13.1.4" class="anchored" data-anchor-id="графостатистичні-показники"><span class="header-section-number">13.1.4</span> Графостатистичні показники</h3>
<section id="ступінь-вершини" class="level4" data-number="13.1.4.1">
<h4 data-number="13.1.4.1" class="anchored" data-anchor-id="ступінь-вершини"><span class="header-section-number">13.1.4.1</span> Ступінь вершини</h4>
<p>Незалежно від того, чи представляють вузли людей, місця, комп’ютери або атоми, розташування вузла в структурі мережі тісно пов’язане з роллю, яку він відіграє в загальній системі. Різні структури уможливлюють різні ролі. Отже, кількісно оцінюючи структурні властивості вузла, можна зрозуміти роль, яку відіграє цей вузол. Числові міри, які характеризують мережеві властивості вузла, називаються мірами центральності. Однією з найпростіших мір центральності є <strong>ступенева центральність</strong> (degree centrality). Ступенева центральність вузла — це просто кількість сусідів, які наявні у вузла. У соціальній мережі ступенева центральність є мірою популярності, і може бути хорошим способом здогадатися, хто влаштовує найкращі вечірки, хто має найбільшу кількість публікацій або хто є монополістом на ринку праці. Ступенева центральність — це досить елементарний приклад, але далі будуть представлені більш складні міри, які часто використовуються в науці складних мереж. Кожна міра центральності кількісно оцінює різний тип важливості і може бути корисною для відповідей на різні типи питань.</p>
<p>Показник ступеневої центральності тісно пов’язаний із такою мірою як <strong>ступінь вершини в мережі</strong> (node degree), яка визначає кількість ребер, з якими з’єднана конкретна досліджувана вершина. У мережі з <span class="math inline">\(N\)</span> вершин і <span class="math inline">\(M\)</span> ребер, ступінь <span class="math inline">\(k_i\)</span> вершини <span class="math inline">\(i\)</span> визначається як</p>
<p><span class="math display">\[
k_i = \sum_{j=1}^M A_{ij}.
\]</span></p>
<p><span class="math inline">\(A\)</span> — матриця суміжності мережі, <span class="math inline">\(A_{ij} = 1\)</span>, якщо існує ребро, що з’єднує вершини <span class="math inline">\(i\)</span> та <span class="math inline">\(j\)</span>, і <span class="math inline">\(A_{ij} = 0\)</span> в іншому випадку.</p>
<p>Околицею вершини <span class="math inline">\(i\)</span> називається множина вершин, які безпосередньо з’єднані з <span class="math inline">\(i\)</span>-им ребром. Околиця <span class="math inline">\(i\)</span> позначається як <span class="math inline">\(N_i\)</span> і визначається як</p>
<p><span class="math display">\[
N_i = \{j \mid A_{ij} = 1\}.
\]</span></p>
<p>Тут <span class="math inline">\(A\)</span> — матриця суміжності мережі; <span class="math inline">\(A_{ij} = 1\)</span>, якщо існує ребро, що з’єднує вершини <span class="math inline">\(i\)</span> та <span class="math inline">\(j\)</span>, і <span class="math inline">\(A_{ij} = 0\)</span> в іншому випадку.</p>
<p>Розглянемо приклад ступеню вершини на прикладі графа <strong>карате-клубу</strong>.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Відомості про граф карате-клубу">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Відомості про граф карате-клубу
</div>
</div>
<div class="callout-body-container callout-body">
<p>Граф карате-клубу — це соціальна мережа, що представляє дружбу між 34 членами карате-клубу, як це спостерігав Вейн В. Захарі у 1977 році. Кожна вершина графа представляє члена клубу, а кожне ребро — дружбу між двома членами. Граф має 34 вершини та 78 ребер. Карате-клуб є відомим прикладом аналізу соціальних мереж і використовувався для вивчення різних властивостей мережі, таких як структура спільноти і міра центральності. Граф характеризується розколом клубу на дві фракції, очолювані інструкторами клубів: вершина 1 та вершина 34. Цей розкол був спричинений суперечкою між двома лідерами, яка врешті-решт призвела до утворення двох окремих клубів карате</p>
</div>
</div>
<div id="cell-102" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.karate_club_graph()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-fig-16" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-16" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-16-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.17: Граф карате-клубу
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-104" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>node <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>neighborhood <span class="op">=</span> <span class="bu">list</span>(nx.neighbors(G_karate, node))</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>neighborhood</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>[0, 1, 3, 7, 8, 9, 13, 27, 28, 32]</code></pre>
</div>
</div>
<div id="cell-105" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ступінь = кількість сусідів </span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(neighborhood)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<pre><code>10</code></pre>
</div>
</div>
<div id="cell-106" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ступінь вершини</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>G_karate.degree(node)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<pre><code>10</code></pre>
</div>
</div>
<div id="cell-107" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Усі ступені вершини</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="bu">dict</span>(G_karate.degree)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<pre><code>{0: 16,
 1: 9,
 2: 10,
 3: 6,
 4: 3,
 5: 4,
 6: 4,
 7: 4,
 8: 5,
 9: 2,
 10: 3,
 11: 1,
 12: 2,
 13: 5,
 14: 2,
 15: 2,
 16: 2,
 17: 2,
 18: 2,
 19: 3,
 20: 2,
 21: 2,
 22: 2,
 23: 5,
 24: 3,
 25: 3,
 26: 2,
 27: 4,
 28: 3,
 29: 4,
 30: 4,
 31: 6,
 32: 12,
 33: 17}</code></pre>
</div>
</div>
<div id="cell-fig-17" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>plt.hist(<span class="bu">sorted</span>(<span class="bu">dict</span>(G_karate.degree).values()))</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Ступінь вершини"</span>)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Частота"</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-17" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-17-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.18: Гістограма ступенів вершини в графі карате-клубу
</figcaption>
</figure>
</div>
</div>
</div>
<p>На <a href="#fig-17" class="quarto-xref">Рис.&nbsp;<span>13.18</span></a> видно, що в мережі карате-клубів наявно достатньо багато учасників клубу, хто має один або декілька зв’язків із іншими членами клубу. Також видно, що серед них є ті, хто має більше 15 знайомих. Представниками з такою кількістю зв’язків можуть бути лідери цих клубів.</p>
</section>
<section id="тріадичне-закриття" class="level4" data-number="13.1.4.2">
<h4 data-number="13.1.4.2" class="anchored" data-anchor-id="тріадичне-закриття"><span class="header-section-number">13.1.4.2</span> Тріадичне закриття</h4>
<p>Міра, представлена в цьому розділі, стосується зв’язків між сусідами вузла, а не самого вузла. Часто буває корисно розглянути, чи мають сусіди вузла тенденцію бути пов’язаними один з одним. У соціальній мережі це питання зводиться до того, щоб запитати, чи товариш вашого товариша є і вашим товаришем одночасно. Ця властивість відома як <strong>транзитивність</strong> (transitivity). Результатом таких стосунків є трикутники: три вузли, пов’язані між собою. Тенденція до виникнення таких трикутників називається <strong>кластеризацією</strong> (clustering). Сильна кластеризація часто свідчить про надійність і надлишковість мережі — якщо один ребро зникає, шлях все ще існує через два інших. Кластеризація вимірюється за допомогою <strong>коефіцієнта локальної кластеризації</strong> (local clustering coefficient), який визначає тенденцію вузлів об’єднуватись у тріади. <strong>Глобальний коефіцієнт кластеризації</strong> (global clustering coefficient) представляє середнє значення по всім локальним кластеризаціям, що були визначені для кожного вузла мережі.</p>
<section id="коефіцієнт-кластеризації" class="level5" data-number="13.1.4.2.1">
<h5 data-number="13.1.4.2.1" class="anchored" data-anchor-id="коефіцієнт-кластеризації"><span class="header-section-number">13.1.4.2.1</span> Коефіцієнт кластеризації</h5>
<p>Коефіцієнт кластеризації вершини <span class="math inline">\(i\)</span> задається формулою:</p>
<p><span class="math display">\[
C_i = \sum_{j,k}A_{ij}A_{jk}A_{ki} \Big/ k_i(k_i - 1),
\]</span></p>
<p>де <span class="math inline">\(k_i=\sum_{j}A_{ij}\)</span> — кількість ребер, що входять у вершину <span class="math inline">\(i\)</span>; <span class="math inline">\(A\)</span> позначає матрицю суміжності.</p>
<div id="cell-114" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># локальна кластеризація </span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>nx.clustering(G, <span class="dv">2</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="55">
<pre><code>0</code></pre>
</div>
</div>
<div id="cell-115" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="co"># список кластеризацій</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>nx.clustering(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<pre><code>{0: 0.16666666666666666,
 1: 0.3333333333333333,
 2: 0,
 3: 0.3333333333333333,
 4: 0,
 5: 0,
 6: 0,
 7: 0,
 8: 0,
 9: 0}</code></pre>
</div>
</div>
</section>
<section id="глобальний-коефіцієнт-кластеризації" class="level5" data-number="13.1.4.2.2">
<h5 data-number="13.1.4.2.2" class="anchored" data-anchor-id="глобальний-коефіцієнт-кластеризації"><span class="header-section-number">13.1.4.2.2</span> Глобальний коефіцієнт кластеризації</h5>
<p>Багато спостережуваних соціальних мереж є більш кластеризованими, ніж це могло б виникнути випадковим чином</p>
<p>Коефіцієнт кластеризації мережі є середнім значенням коефіцієнтів кластеризації всіх <span class="math inline">\(N\)</span> вузлів:</p>
<p><span class="math display">\[
C = N^{-1}\sum_{i=1}^{N} C_i.
\]</span></p>
<div id="cell-119" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co"># середній ступінь кластеризації</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>nx.average_clustering(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>0.08333333333333333</code></pre>
</div>
</div>
</section>
<section id="транзитивність" class="level5" data-number="13.1.4.2.3">
<h5 data-number="13.1.4.2.3" class="anchored" data-anchor-id="транзитивність"><span class="header-section-number">13.1.4.2.3</span> Транзитивність</h5>
<p><strong>Транзитивність</strong> — це властивість мережі, яка вимірює ймовірність того, що якщо два вузли мережі мають спільного сусіда, то вони також будуть безпосередньо з’єднані один з одним. Іншими словами, вона вимірює тенденцію до утворення “трикутників” у мережі.</p>
<p>Формально транзитивність мережі визначається як відношення кількості трикутників у мережі до кількості з’єднаних трійок вузлів (тобто трійок вузлів, які безпосередньо з’єднані один з одним або мають спільного сусіда). У математичній нотації транзитивність мережі позначається як</p>
<p><span class="math display">\[
T = \sum_{i,k,j=1}^{N}A_{ik}A_{kj}A_{ji} \Bigg/ \sum_{i,k,j=1}^{N}A_{ik}A_{ji}.
\]</span></p>
<p>Висока транзитивність вказує на те, що вузли в мережі мають тенденцію до утворення трикутних кластерів або спільнот, тоді як низька транзитивність вказує на те, що мережа є більш випадковою або децентралізованою структурою. Транзитивність тісно пов’язана з поняттям коефіцієнта кластеризації, який вимірює схильність вузлів до утворення локальних кластерів або спільнот.</p>
<div id="cell-122" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co">#транзитивність</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="co">#transitivity зважує вершини з великим ступенем вершини</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>nx.transitivity(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="58">
<pre><code>0.15789473684210525</code></pre>
</div>
</div>
</section>
</section>
<section id="шлях" class="level4" data-number="13.1.4.3">
<h4 data-number="13.1.4.3" class="anchored" data-anchor-id="шлях"><span class="header-section-number">13.1.4.3</span> Шлях</h4>
<p><strong>Шлях</strong> (path) між двома вузлами <span class="math inline">\(A\)</span> та <span class="math inline">\(B\)</span> у мережі — це послідовність вузлів <span class="math inline">\(A, X_1, X_2, ..., X_n, B\)</span> та послідовність ребер <span class="math inline">\((A, X_1), (X_1, X_2), ..., (X_n, B)\)</span>, де кожен вузол та ребро у послідовності є суміжним з попереднім та наступним вузлом або ребром у послідовності.</p>
<p><strong>Довжина шляху</strong> (path length) — це кількість ребер у ньому. Шлях довжиною 1 — це ребро між двома вершинами, шлях довжиною 2 — послідовність з двох ребер і трьох вершин, і так далі. Найкоротший шлях між двома вершинами — це шлях мінімальної довжини, який їх з’єднує.</p>
<div id="cell-126" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co"># згенерувати усі прості шляхи між вершинами 1 та 3</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>paths <span class="op">=</span> nx.all_simple_paths(G, source<span class="op">=</span><span class="dv">1</span>, target<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="co"># перетворити генератор у список</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>Path_List <span class="op">=</span> [path <span class="cf">for</span> path <span class="kw">in</span> paths]</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Список шляхів:"</span>, Path_List)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Список шляхів: [[1, 0, 3], [1, 0, 5, 4, 3], [1, 3]]</code></pre>
</div>
</div>
<div id="cell-127" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>Path1 <span class="op">=</span> Path_List[<span class="dv">0</span>]</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="co"># перевірити, чи є шлях простим у графі</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>is_valid <span class="op">=</span> nx.is_simple_path(G, Path1) <span class="co"># Простий шлях - це шлях, який не містить жодної вершини, що повторюється.</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Чи є шлях простим?"</span>, is_valid)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Чи є шлях простим? True</code></pre>
</div>
</div>
<div id="cell-128" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co"># хибний приклад</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>nx.is_simple_path(G, [<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">5</span>])</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="61">
<pre><code>False</code></pre>
</div>
</div>
<div id="cell-129" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># формуємо список ребер, що формують шлях</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>edge_list <span class="op">=</span> [(Path1[i], Path1[i<span class="op">+</span><span class="dv">1</span>]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Path1)<span class="op">-</span><span class="dv">1</span>)] <span class="co"># len(Path1)-1 = довжина шляху</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>edge_list</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="62">
<pre><code>[(1, 0), (0, 3)]</code></pre>
</div>
</div>
<div id="cell-130" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co"># обчислюємо вагу шляху</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="bu">sum</span>(G[u][v][<span class="st">'weight'</span>] <span class="cf">for</span> u, v <span class="kw">in</span> edge_list <span class="cf">if</span> <span class="st">'weight'</span> <span class="kw">in</span> G[u][v])</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Вага шляху:"</span>, weight)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Вага шляху: 2</code></pre>
</div>
</div>
<section id="геодезична-лінія" class="level5" data-number="13.1.4.3.1">
<h5 data-number="13.1.4.3.1" class="anchored" data-anchor-id="геодезична-лінія"><span class="header-section-number">13.1.4.3.1</span> Геодезична лінія</h5>
<p>Геодезичний шлях між двома вузлами <span class="math inline">\(A\)</span> і <span class="math inline">\(B\)</span> в мережі — це <strong>найкоротший шлях</strong>, який їх з’єднує. Іншими словами, це шлях з мінімальною кількістю ребер, які потрібно пройти, щоб дістатися з вузла <span class="math inline">\(A\)</span> до вузла <span class="math inline">\(B\)</span>. Довжина геодезичного шляху — це кількість ребер у цьому шляху.</p>
<div id="cell-133" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co"># геодезичний шлях = найкоротший шлях </span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>nx.shortest_path(G, <span class="dv">1</span>, <span class="dv">2</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre><code>[1, 0, 2]</code></pre>
</div>
</div>
<div id="cell-fig-18" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="co"># обчислити найкоротший шлях між двома вузлами</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> nx.shortest_path(G, source<span class="op">=</span><span class="dv">1</span>, target<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="co"># обчислити відповідні ребра шляху</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(path[i], path[i<span class="op">+</span><span class="dv">1</span>]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(path)<span class="op">-</span><span class="dv">1</span>)]</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф та шлях </span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.circular_layout(G)</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, pos, with_labels<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G, pos, edgelist<span class="op">=</span>edges, edge_color<span class="op">=</span><span class="st">'r'</span>, width<span class="op">=</span><span class="dv">3</span>)<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\Andrii\AppData\Local\Temp\ipykernel_13844\481497461.py:15: DeprecationWarning: `alltrue` is deprecated as of NumPy 1.25.0, and will be removed in NumPy 2.0. Please use `all` instead.
  nx.draw_networkx_edges(G, pos, edgelist=edges, edge_color='r', width=3);</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-18" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-18-output-2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.19: Граф із виділеним найкоротшим шляхом між вузлами 1 і 3
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-135" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="co"># геодезична довжина </span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>nx.shortest_path_length(G, <span class="dv">1</span>, <span class="dv">2</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="66">
<pre><code>2</code></pre>
</div>
</div>
<p>Пошук геодезичного шляху від вузла <span class="math inline">\(i\)</span> до кожного іншого вузла є обчислювально складним, тому нам потрібен ефективний алгоритм для цього.</p>
<p>Тут ми використовуємо пошук у ширину <span class="citation" data-cites="cormen2022introduction">&nbsp;[<a href="references.html#ref-cormen2022introduction" role="doc-biblioref">5</a>]</span>:</p>
<div id="cell-fig-19" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co"># алгоритм пошуку в ширину</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> nx.bfs_tree(G, <span class="dv">1</span>)</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(T, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-19" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-19-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.20: Повертає орієнтоване дерево, побудоване на основі пошуку в ширину, починаючи з джерела
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-138" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="co"># усі найкоротші шляхи </span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>nx.shortest_path_length(G, <span class="dv">1</span>) <span class="co"># виводимо словник </span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">
<pre><code>{1: 0, 0: 1, 3: 1, 6: 1, 2: 2, 5: 2, 4: 2, 8: 3, 7: 3, 9: 4}</code></pre>
</div>
</div>
<div id="cell-139" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="co"># середній найкоротший шлях </span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>nx.average_shortest_path_length(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre><code>2.4</code></pre>
</div>
</div>
</section>
<section id="звязні-компоненти" class="level5" data-number="13.1.4.3.2">
<h5 data-number="13.1.4.3.2" class="anchored" data-anchor-id="звязні-компоненти"><span class="header-section-number">13.1.4.3.2</span> Зв’язні компоненти</h5>
<p>У простій мережі для <em>кожної</em> пари вершин можна знайти шлях, який їх з’єднує. Це і є визначенням <strong>зв’язного графа</strong>. Ми можемо перевірити цю властивість для заданого графа:</p>
<div id="55979cce" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>nx.is_connected(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>True</code></pre>
</div>
</div>
<p>Не кожен граф зв’язний:</p>
<div id="cell-fig-20" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>G_test <span class="op">=</span> nx.Graph()</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>nx.add_cycle(G_test, (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>G_test.add_edge(<span class="dv">4</span>, <span class="dv">5</span>)</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_test, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-20" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-20-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.21: Розв’язний граф із циклічним шляхом
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cf48526d" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>nx.is_connected(G_test)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>False</code></pre>
</div>
</div>
<p>А NetworkX видасть помилку, якщо ви запитаєте шлях між вузлами, якого не існує:</p>
<div id="64896505" class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>nx.has_path(G_test, <span class="dv">3</span>, <span class="dv">5</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre><code>False</code></pre>
</div>
</div>
<div id="0f414708" class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>nx.shortest_path(G_test, <span class="dv">3</span>, <span class="dv">5</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>NetworkXNoPath: No path between 3 and 5.</code></pre>
</div>
</div>
<p>Візуально ми можемо ідентифікувати дві пов’язані компоненти на графі. Давайте перевіримо це:</p>
<div id="61501587" class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>nx.number_connected_components(G_test)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>2</code></pre>
</div>
</div>
<p>Функція <code>nx.connected_components()</code> отримує граф і повертає список наборів імен вершин, по одному такому набору для кожної зв’язної компоненти. Перевірте, чи відповідають дві множини у наступному списку двом зв’язним компонентам на рисунку графа вище:</p>
<div id="a7fbac9a" class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(nx.connected_components(G_test))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<pre><code>[{1, 2, 3}, {4, 5}]</code></pre>
</div>
</div>
<p>Якщо ви не знайомі з множинами у Python, це колекції елементів без дублікатів. Вони корисні для збору імен вузлів, оскільки імена вузлів повинні бути унікальними. Як і у випадку з іншими колекціями, ми можемо отримати кількість елементів у множині за допомогою функції <code>len</code>:</p>
<div id="df2ff74a" class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>components <span class="op">=</span> <span class="bu">list</span>(nx.connected_components(G_test))</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(components[<span class="dv">0</span>])</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<pre><code>3</code></pre>
</div>
</div>
<p>Нас часто цікавить найбільша зв’язна компонента, яку іноді називають <em>ядром</em> мережі. Ми можемо скористатися вбудованою функцією <code>max</code> у Python, щоб отримати найбільший зв’язну компоненту. За замовчуванням функція <code>max</code> у Python сортує дані у лексикографічному (тобто алфавітному) порядку, що не є корисним у даному випадку. Ми хочемо отримати максимальний зв’язаний компонент при сортуванні в порядку його розміру, тому ми передаємо <code>len</code> як ключову функцію:</p>
<div id="d6fa4246" class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="bu">max</span>(nx.connected_components(G_test), key<span class="op">=</span><span class="bu">len</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">
<pre><code>{1, 2, 3}</code></pre>
</div>
</div>
<p>Хоча часто достатньо мати лише список назв вершин, іноді нам потрібен власне підграф, що містить найбільш зв’язну вершину. Один із способів отримати її — передати список назв вершин у функцію <code>G.subgraph()</code>:</p>
<div id="cell-fig-21" class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>core_nodes <span class="op">=</span> <span class="bu">max</span>(nx.connected_components(G_test), key<span class="op">=</span><span class="bu">len</span>)</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>core <span class="op">=</span> G.subgraph(core_nodes)</span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(core, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-21" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-21-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-21-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-21-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.22: Граф, що представляє підмножину з найбільш зв’язних компонент
</figcaption>
</figure>
</div>
</div>
</div>
<p>Ті з вас, хто використовує завершення написання коду за допомогою табуляції, також помітять функцію <code>nx.connected_component_subgraphs()</code>. Її також можна використати для отримання основного підграфа, але представлений метод є більш ефективним, якщо вас цікавить найбільша зв’язна компонента.</p>
</section>
<section id="направлені-шляхи-та-компоненти" class="level5" data-number="13.1.4.3.3">
<h5 data-number="13.1.4.3.3" class="anchored" data-anchor-id="направлені-шляхи-та-компоненти"><span class="header-section-number">13.1.4.3.3</span> Направлені шляхи та компоненти</h5>
<p>Давайте поширимо ці ідеї про шляхи та зв’язні компоненти на орієнтовані графи.</p>
<div id="cell-fig-22" class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> nx.DiGraph()</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>D.add_edges_from([</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>,<span class="dv">2</span>),</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>,<span class="dv">3</span>),</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>,<span class="dv">2</span>), (<span class="dv">3</span>,<span class="dv">4</span>), (<span class="dv">3</span>,<span class="dv">5</span>),</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">4</span>,<span class="dv">2</span>), (<span class="dv">4</span>,<span class="dv">5</span>), (<span class="dv">4</span>,<span class="dv">6</span>),</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">5</span>,<span class="dv">6</span>),</span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">6</span>,<span class="dv">4</span>),</span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(D, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-22" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-22-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-22-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-22-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.23: Простий орієнтовний граф
</figcaption>
</figure>
</div>
</div>
</div>
<p>Ми знаємо, що в орієнтованому графі ребро з довільної вершини <span class="math inline">\(u\)</span> до довільної вершини <span class="math inline">\(v\)</span> не говорить про те, що існує ребро з <span class="math inline">\(v\)</span> до <span class="math inline">\(u\)</span>. Тобто, для направленого графа ми спостерігатимемо асиметрію шляхів. Зверніть увагу, що цей граф має шлях від 1 до 4, але не у зворотному напрямку.</p>
<div id="4ff3b6b8" class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>nx.has_path(D, <span class="dv">1</span>, <span class="dv">4</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">
<pre><code>True</code></pre>
</div>
</div>
<div id="67b1d4a7" class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>nx.has_path(D, <span class="dv">4</span>, <span class="dv">1</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="82">
<pre><code>False</code></pre>
</div>
</div>
<p>Інші функції NetworkX, що працюють зі шляхами, також враховують цю асиметрію:</p>
<div id="5693b8f4" class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>nx.shortest_path(D, <span class="dv">2</span>, <span class="dv">5</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="83">
<pre><code>[2, 3, 5]</code></pre>
</div>
</div>
<div id="e794eec5" class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>nx.shortest_path(D, <span class="dv">5</span>, <span class="dv">2</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="84">
<pre><code>[5, 6, 4, 2]</code></pre>
</div>
</div>
<p>Оскільки немає ребра з 5 в 3, найкоротший шлях з 5 в 2 не може просто пройти назад по найкоротшому шляху з 2 в 5 — він повинен пройти довшим шляхом через вузли 6 і 4.</p>
<p>Направлені мережі мають два типи зв’язності. <em>Сильно зв’язні</em> означають, що між кожною парою вузлів існує спрямований шлях, тобто з будь-якого вузла ми можемо дістатися до будь-якого іншого вузла, дотримуючись спрямованості ребер. Уявіть собі автомобілі на мережі вулиць з одностороннім рухом: вони не можуть їхати проти потоку транспорту.</p>
<div id="96ba09d5" class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>nx.is_strongly_connected(D)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="85">
<pre><code>False</code></pre>
</div>
</div>
<p><em>Слабка зв’язність</em> говорить про те, що між кожною парою вузлів існує шлях, незалежно від напрямку. Подумайте про пішоходів у мережі вулиць з одностороннім рухом: вони ходять по тротуарах, тому їх не хвилює напрямок руху.</p>
<div id="6210baf9" class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>nx.is_weakly_connected(D)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="86">
<pre><code>True</code></pre>
</div>
</div>
<p>Якщо мережа сильно зв’язана, вона також є і слабко зв’язаною. Зворотне не завжди вірно, як видно з цього прикладу.</p>
<p>Функція <code>is_connected</code> для неорієнтованих графів видасть помилку, якщо задано орієнтований граф.</p>
<div id="afdbf803" class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Це призведе до помилки</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>nx.is_connected(D)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>NetworkXNotImplemented: not implemented for directed type</code></pre>
</div>
</div>
<p>У випадку направленого графа замість <code>nx.connected_components</code> тепер маємо <code>nx.weak_connected_components</code> та <code>nx.strong_connected_components</code>:</p>
<div id="30c52e2c" class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(nx.weakly_connected_components(D))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="88">
<pre><code>[{1, 2, 3, 4, 5, 6}]</code></pre>
</div>
</div>
<div id="ca3ca0e0" class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(nx.strongly_connected_components(D))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="89">
<pre><code>[{2, 3, 4, 5, 6}, {1}]</code></pre>
</div>
</div>
</section>
</section>
<section id="ексцентриситет" class="level4" data-number="13.1.4.4">
<h4 data-number="13.1.4.4" class="anchored" data-anchor-id="ексцентриситет"><span class="header-section-number">13.1.4.4</span> Ексцентриситет</h4>
<p><strong>Ексцентриситет</strong> (eccentricity) вершини <span class="math inline">\(u\)</span> в мережі — це максимальна відстань між <span class="math inline">\(u\)</span> та будь-якою іншою вершиною мережі. Іншими словами, це максимальна довжина найкоротшого шляху між <span class="math inline">\(u\)</span> та будь-якою іншою вершиною. Ексцентриситет мережі — це максимальний ексцентриситет будь-якого вузла мережі.</p>
<div id="cell-178" class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb157"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ексцентриситет</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="co"># найбільша відстань між n та всіма іншими вершинами:</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>nx.eccentricity(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="90">
<pre><code>{0: 3, 1: 4, 2: 4, 3: 4, 4: 3, 5: 3, 6: 5, 7: 4, 8: 4, 9: 5}</code></pre>
</div>
</div>
<div id="cell-179" class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb159"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="co"># діаметр: max Ексцентриситет між двома вузлами у всій мережі (max max)</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>nx.diameter(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="91">
<pre><code>5</code></pre>
</div>
</div>
<div id="cell-180" class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Діаметр - максимальний ексцентриситет</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="bu">max</span>(nx.eccentricity(G).values())</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="92">
<pre><code>5</code></pre>
</div>
</div>
<div id="cell-181" class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="co"># радіус: min Ексцентриситет між двома вузлами у всій мережі (min max)</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>nx.radius(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">
<pre><code>3</code></pre>
</div>
</div>
<div id="cell-182" class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="co"># радіус - мінімальний ексцентриситет</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="bu">min</span>(nx.eccentricity(G).values())</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="94">
<pre><code>3</code></pre>
</div>
</div>
<div id="cell-183" class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="co"># периферія</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Ексцентриситет=діаметр</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>nx.periphery(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="95">
<pre><code>[6, 9]</code></pre>
</div>
</div>
<div id="cell-184" class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="co"># центр графа: Ексцентриситет = радіус</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>nx.center(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="96">
<pre><code>[0, 4, 5]</code></pre>
</div>
</div>
</section>
<section id="центральність" class="level4" data-number="13.1.4.5">
<h4 data-number="13.1.4.5" class="anchored" data-anchor-id="центральність"><span class="header-section-number">13.1.4.5</span> Центральність</h4>
<p>Незалежно від того, чи представляють вузли людей, місця, комп’ютери або атоми, розташування вузла в структурі мережі тісно пов’язане з роллю, яку він відіграє в загальній системі. Різні структури уможливлюють різні ролі. Отже, кількісно оцінюючи структурні властивості вузла, можна зрозуміти роль, яку відіграє цей вузол. Числові міри, які характеризують мережні властивості вузла, називаються мірами <strong>центральності</strong> (centrality). Центральність часто вводять як міру важливості, але є багато способів, у які вузол може бути важливим. Наприклад, однією з найпростіших мір центральності є <strong>ступенева центральність</strong> (degree centrality). Ступенева центральність вузла — це просто кількість сусідів, яких він має (у спрямованій мережі є як ступеневі, так і неступеневі сусіди). У соціальній мережі ступенева центральність є мірою популярності.</p>
<section id="ступенева-центральність-ненаправлені-графи" class="level5" data-number="13.1.4.5.1">
<h5 data-number="13.1.4.5.1" class="anchored" data-anchor-id="ступенева-центральність-ненаправлені-графи"><span class="header-section-number">13.1.4.5.1</span> Ступенева центральність — ненаправлені графи</h5>
<p>Ступенева центральність — це міра важливості вузла в мережі, що базується на кількості зв’язків, які він має з іншими вузлами. Ступеневу центральність вершини <span class="math inline">\(i\)</span> можна обчислити як <span class="math inline">\(C_D(i) = k_i/(n-1)\)</span>, де <span class="math inline">\(k_i\)</span> — ступінь вершини <span class="math inline">\(i\)</span>, тобто кількість ребер, інцидентних вершині, а <span class="math inline">\(n\)</span> — загальна кількість вершин у мережі. Знаменник <span class="math inline">\(n-1\)</span> використовується для того, щоб врахувати той факт, що вершина не може бути з’єднана сама з собою.</p>
<p>Ступенева центральність вузла коливається від 0 до 1, причому більше значення вказує на те, що вузол є більш центральним у мережі. Вузли з високою ступеневою центральністю, як правило, добре пов’язані з іншими вузлами, і їх видалення з мережі може мати значний вплив на її зв’язність.</p>
<p>Розглянемо деякі показники на прикладі графа <strong>карате-клубу</strong>.</p>
<div id="be2e4dcf" class="cell" data-execution_count="97">
<div class="sourceCode cell-code" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Карате-клуб</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.convert_node_labels_to_integers(G_karate, first_label<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-fig-23" class="cell" data-execution_count="98">
<div class="sourceCode cell-code" id="cb172"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Встановіть положення вузлів за допомогою конструктора Камада-Каваї</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.kamada_kawai_layout(G_karate)</span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Будуємо граф з червоними вузлами для вузла 0 (інструктор клубу) і вузла 33 (член клубу): тепер це 1 і 34.</span></span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>red_nodes <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">34</span>]</span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a>node_colors <span class="op">=</span> [<span class="st">'red'</span> <span class="cf">if</span> node <span class="kw">in</span> red_nodes <span class="cf">else</span> <span class="st">'blue'</span> <span class="cf">for</span> node <span class="kw">in</span> G_karate.nodes()]</span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_karate, pos, node_color<span class="op">=</span>node_colors)</span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_karate, pos)</span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Будуємо мітки для вузлів</span></span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_labels(G_karate, pos)<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-23" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-23-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-23-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-23-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.24: Граф карате-клубу з виокремлини лідерами двох фракцій
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-191" class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb173"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ступеневі центральності</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>degCent <span class="op">=</span> nx.degree_centrality(G_karate)</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>degCent</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="99">
<pre><code>{1: 0.48484848484848486,
 2: 0.2727272727272727,
 3: 0.30303030303030304,
 4: 0.18181818181818182,
 5: 0.09090909090909091,
 6: 0.12121212121212122,
 7: 0.12121212121212122,
 8: 0.12121212121212122,
 9: 0.15151515151515152,
 10: 0.06060606060606061,
 11: 0.09090909090909091,
 12: 0.030303030303030304,
 13: 0.06060606060606061,
 14: 0.15151515151515152,
 15: 0.06060606060606061,
 16: 0.06060606060606061,
 17: 0.06060606060606061,
 18: 0.06060606060606061,
 19: 0.06060606060606061,
 20: 0.09090909090909091,
 21: 0.06060606060606061,
 22: 0.06060606060606061,
 23: 0.06060606060606061,
 24: 0.15151515151515152,
 25: 0.09090909090909091,
 26: 0.09090909090909091,
 27: 0.06060606060606061,
 28: 0.12121212121212122,
 29: 0.09090909090909091,
 30: 0.12121212121212122,
 31: 0.12121212121212122,
 32: 0.18181818181818182,
 33: 0.36363636363636365,
 34: 0.5151515151515151}</code></pre>
</div>
</div>
<div id="cell-192" class="cell" data-execution_count="100">
<div class="sourceCode cell-code" id="cb175"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="co"># сортування за ступеневою центральністю</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>sorted_degcent <span class="op">=</span> {k: v <span class="cf">for</span> k, v <span class="kw">in</span> <span class="bu">sorted</span>(degCent.items(), key<span class="op">=</span><span class="kw">lambda</span> item: item[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)}</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>sorted_degcent</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="100">
<pre><code>{34: 0.5151515151515151,
 1: 0.48484848484848486,
 33: 0.36363636363636365,
 3: 0.30303030303030304,
 2: 0.2727272727272727,
 4: 0.18181818181818182,
 32: 0.18181818181818182,
 9: 0.15151515151515152,
 14: 0.15151515151515152,
 24: 0.15151515151515152,
 6: 0.12121212121212122,
 7: 0.12121212121212122,
 8: 0.12121212121212122,
 28: 0.12121212121212122,
 30: 0.12121212121212122,
 31: 0.12121212121212122,
 5: 0.09090909090909091,
 11: 0.09090909090909091,
 20: 0.09090909090909091,
 25: 0.09090909090909091,
 26: 0.09090909090909091,
 29: 0.09090909090909091,
 10: 0.06060606060606061,
 13: 0.06060606060606061,
 15: 0.06060606060606061,
 16: 0.06060606060606061,
 17: 0.06060606060606061,
 18: 0.06060606060606061,
 19: 0.06060606060606061,
 21: 0.06060606060606061,
 22: 0.06060606060606061,
 23: 0.06060606060606061,
 27: 0.06060606060606061,
 12: 0.030303030303030304}</code></pre>
</div>
</div>
<div id="cell-193" class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ступенева центральність вузла</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>degCent[<span class="dv">34</span>]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="101">
<pre><code>0.5151515151515151</code></pre>
</div>
</div>
<div id="cell-fig-24" class="cell" data-execution_count="102">
<div class="sourceCode cell-code" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="co"># відобразити мережу з розмірами вершин на основі їх ступеневої центральності</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a><span class="co"># створити список розмірів вершин на основі ступеневої центральності</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>node_sizes <span class="op">=</span> [<span class="dv">10000</span><span class="op">*</span>v<span class="op">*</span>v <span class="cf">for</span> v <span class="kw">in</span> degCent.values()]</span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate, with_labels<span class="op">=</span><span class="va">True</span>, node_size<span class="op">=</span>node_sizes,pos<span class="op">=</span>nx.spring_layout(G_karate))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-24" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-24-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-24-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-24-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.25: Граф карате-клубу зі збільшеними вершинами на основі їх ступеневої центральності
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-fig-25" class="cell" data-execution_count="103">
<div class="sourceCode cell-code" id="cb180"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="co"># кольори на основі ступеневої центральності</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>node_colors <span class="op">=</span> [v <span class="cf">for</span> v <span class="kw">in</span> degCent.values()]</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate, </span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>                 with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>                 node_size<span class="op">=</span>node_sizes,</span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>                 pos<span class="op">=</span>nx.spring_layout(G_karate), </span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a>                 node_color<span class="op">=</span>node_colors, </span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a>                 cmap<span class="op">=</span>plt.cm.PuBu)</span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a><span class="co"># PuBu розшифровується як "Pu" (фіолетовий) - "Bu" (синій), </span></span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a><span class="co"># і це послідовна карта кольорів, яка варіюється від світло-фіолетового до темно-синього.</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-25" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-25-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-25-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-25-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.26: Граф карате-клубу з виокремленими вершинами на основі їх ступеневої центральності за допомогою різної палітри кольорів
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="ступенева-центральність-направлені-графи" class="level5" data-number="13.1.4.5.2">
<h5 data-number="13.1.4.5.2" class="anchored" data-anchor-id="ступенева-центральність-направлені-графи"><span class="header-section-number">13.1.4.5.2</span> Ступенева центральність — направлені графи</h5>
<div id="cell-fig-26" class="cell" data-execution_count="104">
<div class="sourceCode cell-code" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="co"># направлений граф </span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.DiGraph()</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"A"</span>,<span class="st">"B"</span>)</span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"A"</span>,<span class="st">"D"</span>)</span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"A"</span>,<span class="st">"C"</span>)</span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"B"</span>,<span class="st">"D"</span>)</span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо вузли з мітками</span></span>
<span id="cb181-11"><a href="#cb181-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-26" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-26-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-26-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-26-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.27: Приклад направленого графа
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-198" class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb182"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="co"># вхідний ступінь вершини</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>indegCent <span class="op">=</span> nx.in_degree_centrality(G)</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>indegCent</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="105">
<pre><code>{'A': 0.0,
 'B': 0.3333333333333333,
 'D': 0.6666666666666666,
 'C': 0.3333333333333333}</code></pre>
</div>
</div>
<div id="cell-199" class="cell" data-execution_count="106">
<div class="sourceCode cell-code" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="co"># вихідний</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>outdegCent <span class="op">=</span> nx.out_degree_centrality(G)</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>outdegCent</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="106">
<pre><code>{'A': 1.0, 'B': 0.3333333333333333, 'D': 0.0, 'C': 0.0}</code></pre>
</div>
</div>
<div id="cell-200" class="cell" data-execution_count="107">
<div class="sourceCode cell-code" id="cb186"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="co"># конкретна вершина</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>outdegCent[<span class="st">"A"</span>]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="107">
<pre><code>1.0</code></pre>
</div>
</div>
</section>
<section id="ступінь-близькості" class="level5" data-number="13.1.4.5.3">
<h5 data-number="13.1.4.5.3" class="anchored" data-anchor-id="ступінь-близькості"><span class="header-section-number">13.1.4.5.3</span> Ступінь близькості</h5>
<p>Міра, відома як <strong>ступінь близькості</strong> (closeness centrality), є однією з найстаріших мір центральності, що використовується в мережній науці, запропонована соціологом Алексом Бавеласом у 1950 році. Близькість визначається як зворотна величина до <strong>віддаленості</strong> (farness). Що таке віддаленість? Більш зрозуміло, віддаленість вузла — це сума відстаней між цим вузлом і всіма іншими вузлами. Отже, вузол з високою центральністю близькості знаходиться буквально поруч з іншими вузлами. Центральність вузла вимірює, наскільки швидко він може поширювати інформацію або вплив по всій мережі, оскільки вузли з меншою середньою відстанню до всіх інших вузлів можуть спілкуватися більш ефективно. Крім того, вузли з високим показником центральності часто розташовані в центрі мережі, і їх видалення може мати значний вплив на зв’язність мережі.</p>
<p>Ступінь близькості вузла <span class="math inline">\(i\)</span> можна обчислити як <span class="math inline">\(C_C(i) = ( \sum_{j \neq i} d_{ij} )^{-1}\)</span>, де <span class="math inline">\(d_{ij}\)</span> — найкоротша відстань між вузлами <span class="math inline">\(i\)</span> та <span class="math inline">\(j\)</span>. Ступінь близькості вузла коливається від 0 до 1, причому більше значення вказує на меншу середню відстань до всіх інших вузлів мережі.</p>
<p>У наступному прикладі використовується функція NetworkX <code>closeness_centrality()</code> для обчислення значень центральності для мережі карате клубу та відображення 10 найближчих один до одного каратистів:</p>
<div id="cell-203" class="cell" data-execution_count="108">
<div class="sourceCode cell-code" id="cb188"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>closeness <span class="op">=</span> nx.closeness_centrality(G_karate)</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="bu">sorted</span>(closeness.items(), key<span class="op">=</span><span class="kw">lambda</span> x:x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)[:<span class="dv">10</span>]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="108">
<pre><code>[(1, 0.5689655172413793),
 (3, 0.559322033898305),
 (34, 0.55),
 (32, 0.5409836065573771),
 (9, 0.515625),
 (14, 0.515625),
 (33, 0.515625),
 (20, 0.5),
 (2, 0.4852941176470588),
 (4, 0.4647887323943662)]</code></pre>
</div>
</div>
<div id="cell-fig-27" class="cell" data-execution_count="109">
<div class="sourceCode cell-code" id="cb190"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="co"># намалювати мережу з розмірами вершин на основі їх ступеня близькості</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a><span class="co"># створити список розмірів вершин на основі ступеня близькості</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>node_sizes <span class="op">=</span> [<span class="dv">3000</span><span class="op">*</span>v<span class="op">*</span>v <span class="cf">for</span> v <span class="kw">in</span> closeness.values()]</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a><span class="co"># кольори на основі ступеневої близькості</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>node_colors <span class="op">=</span> [v <span class="cf">for</span> v <span class="kw">in</span> closeness.values()]</span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate, </span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a>                 with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a>                 node_size<span class="op">=</span>node_sizes, </span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a>                 pos<span class="op">=</span>nx.spring_layout(G_karate), </span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a>                 node_color<span class="op">=</span>node_colors, </span>
<span id="cb190-16"><a href="#cb190-16" aria-hidden="true" tabindex="-1"></a>                 cmap<span class="op">=</span>plt.get_cmap(<span class="st">'plasma'</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-27" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-27-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-27-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-27-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.28: Граф карате-клубу з виокремлини вершинами на основі їх ступеня близькості
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="ступінь-посередництва" class="level5" data-number="13.1.4.5.4">
<h5 data-number="13.1.4.5.4" class="anchored" data-anchor-id="ступінь-посередництва"><span class="header-section-number">13.1.4.5.4</span> Ступінь посередництва</h5>
<p>У популярній дитячій грі “Телефон” один гравець починає з того, що шепоче повідомлення іншому, той шепоче це повідомлення іншому і так далі. Врешті-решт, останній гравець промовляє повідомлення вголос. Як правило, фінальне повідомлення не має нічого спільного з початковим. Кожного разу, коли повідомлення передається від людини до людини, воно може змінюватися, можливо, через те, що його неправильно почули, а можливо, через те, що його навмисно змінили. У більш складних соціальних мережах, таких як організації та громадські рухи, особи, які з’єднують різні частини мережі, мають найбільші можливості фільтрувати, посилювати та змінювати інформацію. Таких людей називають брокерами, а ребра, що з’єднують віддалені частини мережі, — мостами. Важливість таких вузлів і ребер не обмежується соціальними мережами. У потокових мережах — таких як залізниці, водопроводи та телекомунікаційні системи — вузли що з’єднують віддалені частини мережі, можуть діяти як вузькі місця, обмежуючи обсяг потоку. Виявлення таких вузьких місць дає змогу збільшити їхню пропускну здатність і захистити їх від збоїв та атак. Мости і брокери важливі, тому що вони знаходяться між різними частинами мережі. Відповідно, тип центральності, який використовується для визначення мостів і брокерів називається <strong>cтупенем посередництва</strong> (betweenness centrality).</p>
<p>Ступінь посередництва — це міра того, наскільки вузол лежить на найкоротших шляхах між іншими вузлами мережі. Ступінь посередництва для вузла <span class="math inline">\(i\)</span> можна обчислити як <span class="math inline">\(C_B(i) = \sum_{s \neq i \neq t} \sigma_{st}(i)/\sigma_{st}\)</span>, в якій <span class="math inline">\(s\)</span> і <span class="math inline">\(t\)</span> — два вузли мережі, <span class="math inline">\(\sigma_{st}\)</span> — загальна кількість найкоротших шляхів між <span class="math inline">\(s\)</span> і <span class="math inline">\(t\)</span>, а <span class="math inline">\(\sigma_{st}(i)\)</span> — кількість найкоротших шляхів між <span class="math inline">\(s\)</span> і <span class="math inline">\(t\)</span>, які проходять через вузол <span class="math inline">\(i\)</span>.</p>
<p>Ступінь посередництва змінюється від 0 до 1, причому більше значення вказує на більшу кількість найкоротших шляхів, що проходять через вершину. Вузли з високим значенням центральності часто розташовані на “мостах” між різними кластерами або спільнотами в мережі, і їх видалення може мати значний вплив на зв’язність мережі.</p>
<p>Ступінь посередництва базується на припущенні, що чим більше найкоротших шляхів проходить через вершину (або ребро), тим більше вона виступає в ролі брокера (або моста). Для ступеня посередництва знаходять найкоротші шляхи між кожною парою вузлів. Значення ступеня посередництва для вузла або ребра — це просто кількість цих шляхів, що проходять через нього. На наступній діаграмі показано приклад мережі та розраховані значення посередництва для кожної вершини та ребра. Для кожної пари вершин показано найкоротший шлях (за винятком тривіальних шляхів довжиною 1). Посередництво вузла — це сума шляхів, які проходять через цей вузол. Посередництво ребра — це кількість нетривіальних шляхів, які проходять через це ребро, плюс 1 для самого ребра.</p>
<div id="fig-betweenness" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-betweenness-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Images\lab_13\betweenness.png" style="height:8cm" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-betweenness-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.29: Усі нетривіальні найкоротші шляхи та отримані центри посередництва
</figcaption>
</figure>
</div>
<p>Ступінь посередництва між вузлами легко обчислюється в NetworkX за допомогою функції <code>betweenness_centrality()</code>. Ця функція повертає словник, який зіставляє позначення вузлів зі значеннями посередництва. Якщо аргумент <code>normalized</code> має значення <code>True</code> (за замовчуванням), значення ступеня посередництва ділиться на кількість пар вузлів, що може бути корисним для порівняння значень посередництва, що мають різні масштаби. Якщо аргумент <code>endpoints</code> має значення <code>True</code> (за замовчуванням False), то кінцеві точки шляху будуть включені в розрахунок посередництва.</p>
<div id="cell-211" class="cell" data-execution_count="110">
<div class="sourceCode cell-code" id="cb191"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>btwnCent <span class="op">=</span> nx.betweenness_centrality(G_karate, endpoints <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a><span class="bu">sorted</span>(btwnCent.items(), key<span class="op">=</span><span class="kw">lambda</span> x:x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)[:<span class="dv">10</span>]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="110">
<pre><code>[(1, 0.43763528138528146),
 (34, 0.30407497594997596),
 (33, 0.145247113997114),
 (3, 0.14365680615680618),
 (32, 0.13827561327561325),
 (9, 0.05592682780182781),
 (2, 0.053936688311688304),
 (14, 0.04586339586339586),
 (20, 0.03247504810004811),
 (6, 0.02998737373737374)]</code></pre>
</div>
</div>
<div id="cell-fig-28" class="cell" data-execution_count="111">
<div class="sourceCode cell-code" id="cb193"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="co"># відобразити мережу з розмірами вершин на основі їх ступеня посередництва</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a><span class="co"># створити список розмірів вершин на основі ступеня посередництва</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>node_sizes <span class="op">=</span> [<span class="dv">10000</span><span class="op">*</span>v<span class="op">*</span>v <span class="cf">for</span> v <span class="kw">in</span> btwnCent.values()]</span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a><span class="co"># кольори на основі ступеня посередництва</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>node_colors <span class="op">=</span> [v <span class="cf">for</span> v <span class="kw">in</span> btwnCent.values()]</span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate, with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a>        node_size<span class="op">=</span>node_sizes, </span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>        pos<span class="op">=</span>nx.spring_layout(G_karate), </span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a>        node_color<span class="op">=</span>node_colors, </span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a>        cmap<span class="op">=</span>plt.get_cmap(<span class="st">'viridis'</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-28" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-28-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-28-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-28-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.30: Граф карате-клубу з виокремлини вершинами на основі їх ступеня посередництва вершин
</figcaption>
</figure>
</div>
</div>
</div>
<p>Видно, що високим рівнем посередництва характеризуються вершини 1, 34 і 33. Високий рівень посередництва між ними свідчить про те, що ці особи є важливими інформаційними посередниками в клубі карате. Можливо, вони є найбільш вправними каратистами.</p>
<p>Ступінь посередництва для ребер — це міра того, наскільки ребро лежить на найкоротших шляхах між іншими ребрами в мережі. Посередництво ребра <span class="math inline">\(e\)</span> можна обчислити так:</p>
<p><span class="math display">\[
C_B(e) = \sum_{s \neq e \neq t} \sigma_{st}(e) / \sigma_{st}.
\]</span></p>
<p><span class="math inline">\(s\)</span> і <span class="math inline">\(t\)</span> — дві вершини мережі, <span class="math inline">\(\sigma_{st}\)</span> — загальна кількість найкоротших шляхів між <span class="math inline">\(s\)</span> і <span class="math inline">\(t\)</span>, а <span class="math inline">\(\sigma_{st}(e)\)</span> — кількість найкоротших шляхів між <span class="math inline">\(s\)</span> і <span class="math inline">\(t\)</span>, які проходять через ребро <span class="math inline">\(e\)</span>.</p>
<p>Ступінь посередництва ребра змінюється від 0 до 1, причому більше значення вказує на більшу кількість найкоротших шляхів, які проходять через ребро. Ребра з високою посередництвом часто розташовані на “мостах” між різними кластерами або спільнотами в мережі, і їх видалення може мати значний вплив на зв’язність мережі.</p>
<div id="cell-215" class="cell" data-execution_count="112">
<div class="sourceCode cell-code" id="cb194"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>btwnCent_edge <span class="op">=</span> nx.edge_betweenness_centrality(G_karate, normalized<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="bu">sorted</span>(btwnCent_edge.items(), key<span class="op">=</span><span class="kw">lambda</span> x:x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)[:<span class="dv">10</span>] </span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="112">
<pre><code>[((1, 32), 0.1272599949070537),
 ((1, 7), 0.07813428401663695),
 ((1, 6), 0.07813428401663694),
 ((1, 3), 0.0777876807288572),
 ((1, 9), 0.07423959482783014),
 ((3, 33), 0.06898678663384543),
 ((14, 34), 0.06782389723566191),
 ((20, 34), 0.05938233879410351),
 ((1, 12), 0.058823529411764705),
 ((27, 34), 0.0542908072319837)]</code></pre>
</div>
</div>
<div id="cell-fig-29" class="cell" data-execution_count="114">
<div class="sourceCode cell-code" id="cb196"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="co"># візуалізувати мережу з розмірами вершин на основі ступеня посередництва їх ребер</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a><span class="co"># кольори ребер на основі ступеня посередництва ребер</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>edge_colors <span class="op">=</span> [v <span class="cf">for</span> v <span class="kw">in</span> btwnCent_edge.values()]</span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>edge_widths <span class="op">=</span> [v<span class="op">*</span><span class="dv">100</span> <span class="cf">for</span> v <span class="kw">in</span> btwnCent_edge.values()]</span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb196-9"><a href="#cb196-9" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate, </span>
<span id="cb196-10"><a href="#cb196-10" aria-hidden="true" tabindex="-1"></a>        with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb196-11"><a href="#cb196-11" aria-hidden="true" tabindex="-1"></a>        pos<span class="op">=</span>nx.spring_layout(G_karate), </span>
<span id="cb196-12"><a href="#cb196-12" aria-hidden="true" tabindex="-1"></a>        edge_color<span class="op">=</span>edge_colors, </span>
<span id="cb196-13"><a href="#cb196-13" aria-hidden="true" tabindex="-1"></a>        width<span class="op">=</span>edge_widths)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-29" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-29-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-29-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-29-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.31: Граф карате-клубу з виокремлини ребрами на основі їх ступеня посередництва ребер
</figcaption>
</figure>
</div>
</div>
</div>
<p>Якщо розглядати, наприклад, топ 3 ребер із найбільшим ступенем посередництва, ми побачимо, що, як правило, найкраща комунікація проходить у тренера з учнями під номерами 32, 7, 6, 3 тощо.</p>
</section>
<section id="ступінь-впливовості" class="level5" data-number="13.1.4.5.5">
<h5 data-number="13.1.4.5.5" class="anchored" data-anchor-id="ступінь-впливовості"><span class="header-section-number">13.1.4.5.5</span> Ступінь впливовості</h5>
<p>Уявіть, що у вас є важливе повідомлення, яке потрібно донести до цілої групи (наприклад, до вашого роботодавця або школи), але ви можете передати його лише одній людині. Кому б ви це сказали? Ви б хотіли знайти когось, хто має хороші зв’язки з усією мережею. Ви можете спробувати звернутися до людини з найвищою ступеневою центральністю (найбільшою кількістю друзів). Недоліком такого підходу є те, що її друзі можуть бути не дуже добре пов’язані з рештою мережі. Наприклад, у гіпотетичній компанії директор з продажу в окремому регіоні може знати найбільше людей, але не знати, як зв’язатися з іншими відділами чи регіонами. Замість нього краще знайти когось, хто має тісні зв’язки з іншими людьми, які мають тісні зв’язки, наприклад, генерального директора (або, що більш ймовірно, його помічника). Таких людей іноді називають <strong>хабами</strong>, тому що, подібно до центру колеса зі спицями, вони з’єднують між собою багато різних точок. Цю концепцію високозв’язних хабів добре відображає показник, який називається <strong>ступенем впливовості</strong> (eigenvector centrality).</p>
<p>Ступінь впливовості вершини <span class="math inline">\(i\)</span> можна визначити через головний власний вектор матриці суміжності <span class="math inline">\(\mathbf{A}\)</span> мережі:</p>
<p><span class="math display">\[
\mathbf{Av} = \lambda \mathbf{v},
\]</span></p>
<p>де <span class="math inline">\(\mathbf{v}\)</span> — власний вектор, що відповідає найбільшому власному значенню <span class="math inline">\(\lambda\)</span>. Ступінь впливовості вершини <span class="math inline">\(i\)</span> задається <span class="math inline">\(i\)</span>-им елементом <span class="math inline">\(\mathbf{v}\)</span>.</p>
<p>Ступінь впливовості вузла коливається від 0 до 1, причому більше значення вказує на більшу важливість вузла та його сусідів у мережі. Вузли з високим ступенем впливовості часто розташовані в центрі мережі і добре пов’язані з іншими сильно пов’язаними вузлами, і їх видалення може мати значний вплив на зв’язність мережі.</p>
<div id="cell-221" class="cell" data-execution_count="115">
<div class="sourceCode cell-code" id="cb197"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>eigenvector_centrality <span class="op">=</span> nx.eigenvector_centrality_numpy(G_karate)</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a><span class="bu">sorted</span>(eigenvector_centrality.items(), key<span class="op">=</span><span class="kw">lambda</span> x:x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)[:<span class="dv">10</span>]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="115">
<pre><code>[(34, 0.3733634702914831),
 (1, 0.3554914445245666),
 (3, 0.3171925044864317),
 (33, 0.30864421979104706),
 (2, 0.2659599195524917),
 (9, 0.22740390712540018),
 (14, 0.22647272014248135),
 (4, 0.21117972037789046),
 (32, 0.19103384140654373),
 (31, 0.17475830231435288)]</code></pre>
</div>
</div>
<div id="cell-fig-30" class="cell" data-execution_count="116">
<div class="sourceCode cell-code" id="cb199"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="co"># відображаємо мережу з розмірами вершин на основі їх ступеня впливовості</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a><span class="co"># створити список розмірів вершин на основі ступеня впливовості</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>node_sizes <span class="op">=</span> [<span class="dv">10000</span><span class="op">*</span>v<span class="op">*</span>v <span class="cf">for</span> v <span class="kw">in</span> eigenvector_centrality.values()]</span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a><span class="co"># кольори на основі ступеневої впливовості</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a>node_colors <span class="op">=</span> [v <span class="cf">for</span> v <span class="kw">in</span> eigenvector_centrality.values()]</span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true" tabindex="-1"></a><span class="co"># будуємо граф</span></span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate, </span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true" tabindex="-1"></a>        with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true" tabindex="-1"></a>        node_size<span class="op">=</span>node_sizes, </span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true" tabindex="-1"></a>        pos<span class="op">=</span>nx.spring_layout(G_karate), </span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true" tabindex="-1"></a>        node_color<span class="op">=</span>node_colors, </span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true" tabindex="-1"></a>        cmap<span class="op">=</span>plt.get_cmap(<span class="st">'Purples'</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-30" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-30-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-30-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-30-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.32: Граф карате-клубу з виокремлини вершини на основі їх ступеня впливовості
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="широкомасштабний-опис-мереж" class="level3" data-number="13.1.5">
<h3 data-number="13.1.5" class="anchored" data-anchor-id="широкомасштабний-опис-мереж"><span class="header-section-number">13.1.5</span> Широкомасштабний опис мереж</h3>
<p>Широкомасштабні структури можуть сильно відрізнятися від мережі до мережі. Ці відмінності часто вказують на різні типи мереж (наприклад, соціальні та технологічні). Широкомасштабні структури також можуть мати важливі наслідки для функціональних властивостей, таких як як стійкість до збоїв і атак. Розглянемо аналіз структурних показників для мереж різних типів.</p>
<p>Як ви вже могли переконатися на прикладі графа карате-клубу, NetworkX надає декілька вбудованих наборів мережних даних, які можна використовувати для тестування та експериментів. Ці набори даних доступні в самій бібліотеці NetworkX і можуть бути завантажені за допомогою функцій, які починаються з префікса <code>nx.</code>, за яким слідує назва набору даних.</p>
<p>Ось кілька прикладів вбудованих мережних наборів даних у NetworkX:</p>
<ul>
<li><p><code>nx.karate_club_graph()</code> — повертає мережу Zachary’s Karate Club, соціальну мережу карате-клубу, де кожен вузол представляє члена клубу, а кожне ребро представляє дружні стосунки між членами;</p></li>
<li><p><code>nx.les_miserables_graph()</code> — повертає мережу персонажів роману Віктора Гюго “Знедолені”, де кожен вузол представляє персонажа роману, а кожне ребро представляє спільну появу двох персонажів у главі;</p></li>
<li><p><code>nx.davis_southern_women_graph()</code> — повертає мережу соціальних взаємодій між жінками у містечку на півдні США в 1930-х роках, де кожен вузол представляє жінку, а кожне ребро — соціальні стосунки між двома жінками.</p></li>
</ul>
<p>Це лише кілька прикладів вбудованих мережних наборів даних у NetworkX. Ви можете знайти більше інформації про доступні набори даних та їх використання в документації NetworkX.</p>
<div id="2d63388c" class="cell" data-execution_count="117">
<div class="sourceCode cell-code" id="cb200"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="co"># генеруємо першу мережу</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>mr_hi <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>john_a <span class="op">=</span> <span class="dv">33</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a><span class="co"># генеруємо другу мережу </span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>G_novel <span class="op">=</span> nx.les_miserables_graph()</span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a><span class="co"># генеруємо третю мережу </span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>G_woman <span class="op">=</span> nx.davis_southern_women_graph()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Наступний код візуалізує три приклади мереж:</p>
<div id="cell-fig-31" class="cell" data-execution_count="119">
<div class="sourceCode cell-code" id="cb201"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Карате"</span>)</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_karate, node_size<span class="op">=</span><span class="dv">0</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Роман"</span>)</span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_novel, node_size<span class="op">=</span><span class="dv">0</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_title(<span class="st">"Жінки"</span>)</span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_woman, node_size<span class="op">=</span><span class="dv">0</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax[<span class="dv">2</span>])</span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-31" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-31-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-31-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-31-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.33: Мережі карате-клубу, персонажів роману та соціальної взаємодії між жінками в містечку на півдні США в 1930-х роках
</figcaption>
</figure>
</div>
</div>
</div>
<section id="діаметр-і-найкоротший-шлях" class="level4" data-number="13.1.5.1">
<h4 data-number="13.1.5.1" class="anchored" data-anchor-id="діаметр-і-найкоротший-шлях"><span class="header-section-number">13.1.5.1</span> Діаметр і найкоротший шлях</h4>
<p>Мережі можуть бути охарактеризовані відповідно до розподілу довжини найкоротшого шляху. Наведена нижче функція будує гістограму всіх найкоротших шляхів у мережі:</p>
<div id="31813f15" class="cell" data-execution_count="120">
<div class="sourceCode cell-code" id="cb202"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> path_length_histogram(G, title<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># знаходимо довжини шляхів</span></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    length_source_target <span class="op">=</span> <span class="bu">dict</span>(nx.shortest_path_length(G))</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># конвертуємо словник словників до звичайного списку</span></span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>    all_shortest <span class="op">=</span> <span class="bu">sum</span>([</span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">list</span>(length_target.values())</span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length_target</span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> length_source_target.values()],</span>
<span id="cb202-9"><a href="#cb202-9" aria-hidden="true" tabindex="-1"></a>    [])</span>
<span id="cb202-10"><a href="#cb202-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># розраховуємо цілочисельні біни</span></span>
<span id="cb202-11"><a href="#cb202-11" aria-hidden="true" tabindex="-1"></a>    high <span class="op">=</span> <span class="bu">max</span>(all_shortest)</span>
<span id="cb202-12"><a href="#cb202-12" aria-hidden="true" tabindex="-1"></a>    bins <span class="op">=</span> [<span class="op">-</span><span class="fl">0.5</span> <span class="op">+</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(high <span class="op">+</span> <span class="dv">2</span>)]</span>
<span id="cb202-13"><a href="#cb202-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># будуємо гістограму</span></span>
<span id="cb202-14"><a href="#cb202-14" aria-hidden="true" tabindex="-1"></a>    plt.hist(all_shortest, bins<span class="op">=</span>bins, rwidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb202-15"><a href="#cb202-15" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb202-16"><a href="#cb202-16" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Відстань"</span>)</span>
<span id="cb202-17"><a href="#cb202-17" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Підрахунок"</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Тепер давайте порівняємо розподіл довжин шляхів для трьох мереж:</p>
<div id="cell-fig-32" class="cell" data-execution_count="121">
<div class="sourceCode cell-code" id="cb203"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Створюємо рисунок</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Будуємо гістограми найкоротших шляхів</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>path_length_histogram(G_karate, title<span class="op">=</span><span class="st">"Карате"</span>)</span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>path_length_histogram(G_novel, title<span class="op">=</span><span class="st">"Роман"</span>)</span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>path_length_histogram(G_woman, title<span class="op">=</span><span class="st">"Жінки"</span>)</span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-32" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-32-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-32-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-32-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.34: Гістограми найкоротших шляхів у мережах карате-клубу, персонажів роману та соціальної взаємодії між жінками в містечку на півдні США в 1930-х роках
</figcaption>
</figure>
</div>
</div>
</div>
<p>Усі три графи мають достатньо малі найкоротші шляхи. Соціальні мережі, як правило, мають короткі шляхи, що відомо як <strong>феномен малого світу</strong>.</p>
<p>Хоча розподіл повної довжини шляху є інформативним, він є дещо громіздким, тому корисно використовувати агреговані показники. Однією з таких мір є <strong>середня довжина найкоротшого шляху</strong>, яку можна обчислити наступним чином:</p>
<div id="42871ca3" class="cell" data-execution_count="122">
<div class="sourceCode cell-code" id="cb204"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Середній найкоротший шлях для карате-клубу: "</span>, nx.average_shortest_path_length(G_karate))</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Середній найкоротший шлях для роману: "</span>, nx.average_shortest_path_length(G_novel))</span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Середній найкоротший шлях для жінок: "</span>, nx.average_shortest_path_length(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Середній найкоротший шлях для карате-клубу:  2.408199643493761
Середній найкоротший шлях для роману:  2.6411483253588517
Середній найкоротший шлях для жінок:  2.306451612903226</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Попередження
</div>
</div>
<div class="callout-body-container callout-body">
<p>У роз’єднаній на дві або або більше компонентів мережі без ребра між ними середня довжина шляху стає нескінченною. Цю проблему можна вирішити кількома способами, наприклад, використання гармонічного, а не арифметичного середнього, або усереднення середнього значення найкоротших шляхів у межах кожної зв’язної компоненти. Який метод є доречним, залежить від типу мережі, що аналізується</p>
</div>
</div>
<p>Крім того, розмір мережі може бути охарактеризований найбільшою довжиною шляху довжиною, яка називається <strong>діаметром</strong>. Діаметри трьох прикладів мереж можна знайти за допомогою функції <code>diameter()</code>:</p>
<div id="c44897cb" class="cell" data-execution_count="123">
<div class="sourceCode cell-code" id="cb206"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Діаметр для карате-клубу: "</span>, nx.diameter(G_karate))</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Діаметр для роману: "</span>, nx.diameter(G_novel))</span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Діаметр для жінок: "</span>, nx.diameter(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Діаметр для карате-клубу:  5
Діаметр для роману:  5
Діаметр для жінок:  4</code></pre>
</div>
</div>
<p>Як ми можемо бачити результати доволі схожі на попередні. На відміну від середньої довжини найкоротшого шляху, діаметр залежить лише від одного шляху. Як наслідок, один викид може значно збільшити діаметр. Однак у такому разі діаметр може бути гарним показником найгіршої довжини шляху.</p>
</section>
<section id="вимірювання-стійкості-мережі" class="level4" data-number="13.1.5.2">
<h4 data-number="13.1.5.2" class="anchored" data-anchor-id="вимірювання-стійкості-мережі"><span class="header-section-number">13.1.5.2</span> Вимірювання стійкості мережі</h4>
<p><strong>Стійкість</strong> (resilience) — це здатність системи протистояти збоям і атакам. Наприклад, в електромережі стійкість означає продовження подачі електроенергії, коли лінія електропередач або генератор вийшли з ладу. У дорожньому русі це може означати можливість перенаправляти автомобілі, коли вулиця перекрита через аварію.</p>
<p>Стійкість — це фундаментальна властивість мережі, оскільки вона зазвичай досягається за допомогою резервних шляхів. Коли один шлях більше не доступний, інші все ще можуть бути використані.</p>
<p>Найпростішим (і найгрубішим) показником стійкості є <strong>щільність мережі</strong> (density): частка можливих ребер, які існують. Чим більше ребер у мережі, тим більше надлишкових шляхів існує між її вузлами. Наступний код використовує функцію <code>density()</code> для обчислення цього значення:</p>
<div id="237a67fa" class="cell" data-execution_count="124">
<div class="sourceCode cell-code" id="cb208"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Щільність для карате-клубу: "</span>, nx.density(G_karate))</span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Щільність для роману: "</span>, nx.density(G_novel))</span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Щільність для жінок: "</span>, nx.density(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Щільність для карате-клубу:  0.13903743315508021
Щільність для роману:  0.08680792891319207
Щільність для жінок:  0.17943548387096775</code></pre>
</div>
</div>
<p>Мережа зазвичай вважається розрідженою, якщо кількість ребер близька до <span class="math inline">\(N\)</span> (кількість вузлів), і щільною, якщо кількість ребер близька до <span class="math inline">\(N^2\)</span>.</p>
<p>Можна бачити, що найбільш стійкою (щільною) серед усіх трьох графів є мережа жінок.</p>
</section>
<section id="найменші-розрізи" class="level4" data-number="13.1.5.3">
<h4 data-number="13.1.5.3" class="anchored" data-anchor-id="найменші-розрізи"><span class="header-section-number">13.1.5.3</span> Найменші розрізи</h4>
<p>Більш складні показники відмовостійкості базуються на концепції найменших розрізів. <strong>Найменший розріз</strong> (min-cut) — це кількість вузлів (або ребер), які потрібно видалити, щоб розділити мережу на дві незв’язані частини. Найменші розрізи можна знайти або між двома конкретними вузлами, або над усіма парами вузлів.</p>
<p>У NetworkX найменший розріз між двома вузлами знаходять за допомогою функції <code>minimum_st_node_cut()</code>. Зауважте, що ця функція знаходиться у пакеті <code>connectivity</code> і має бути імпортована окремо на додачу до базового пакету <code>networkx</code>. Наступний код знаходить мінімальну довжину шляху між містером Хі та Джоном А. у мережі карате-клубу:</p>
<div id="4387a2a9" class="cell" data-execution_count="125">
<div class="sourceCode cell-code" id="cb210"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx.algorithms.connectivity <span class="im">as</span> nxcon</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>nxcon.minimum_st_node_cut(G_karate, mr_hi, john_a)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="125">
<pre><code>{2, 8, 13, 19, 30, 31}</code></pre>
</div>
</div>
<p>Попередній результат говорить про те, що вузли 2, 8, 12, 19, 30, 31 потрібно видалити, щоб розділити мережу на дві половини, одна з яких містить містера Хі, а інша — Джона А.</p>
<p>Аналогічно, найменший розріз ребер:</p>
<div id="2452e33d" class="cell" data-execution_count="126">
<div class="sourceCode cell-code" id="cb212"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>nxcon.minimum_st_edge_cut(G_karate, mr_hi, john_a)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="126">
<pre><code>{(0, 8),
 (0, 31),
 (1, 30),
 (2, 8),
 (2, 27),
 (2, 28),
 (2, 32),
 (9, 33),
 (13, 33),
 (19, 33)}</code></pre>
</div>
</div>
<p>Якщо потрібно знати лише розмір найменшого розрізу, можна скористатися функціями <code>node_connectivity()</code> або <code>edge_connectivity()</code> базового пакету <code>networkx</code>. У наступному прикладі обчислюються ці значення для мережі карате-клубу:</p>
<div id="210b1160" class="cell" data-execution_count="127">
<div class="sourceCode cell-code" id="cb214"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>nx.node_connectivity(G_karate, mr_hi, john_a)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="127">
<pre><code>6</code></pre>
</div>
</div>
<div id="5068d4da" class="cell" data-execution_count="128">
<div class="sourceCode cell-code" id="cb216"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>nx.edge_connectivity(G_karate, mr_hi, john_a)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="128">
<pre><code>10</code></pre>
</div>
</div>
</section>
<section id="звязність" class="level4" data-number="13.1.5.4">
<h4 data-number="13.1.5.4" class="anchored" data-anchor-id="звязність"><span class="header-section-number">13.1.5.4</span> Зв’язність</h4>
<p>Найменші розрізи можуть бути використані для визначення показників <strong>зв’язності</strong> (connectivity) для всієї мережі. Ці міри дуже корисні для кількісної оцінки стійкості мережі.</p>
<p>Зв’язність вузлів — це найменший мінімальний розріз між усіма парами вузлів. Зв’язність ребер визначається аналогічно. Фактичні значення розрізів між вузлами та ребрами можна знайти за допомогою пакету <code>connection</code>:</p>
<div id="2ff06825" class="cell" data-execution_count="129">
<div class="sourceCode cell-code" id="cb218"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>nxcon.minimum_node_cut(G_karate)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="129">
<pre><code>{0}</code></pre>
</div>
</div>
<div id="21aabcd6" class="cell" data-execution_count="130">
<div class="sourceCode cell-code" id="cb220"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>nxcon.minimum_edge_cut(G_karate)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="130">
<pre><code>{(11, 0)}</code></pre>
</div>
</div>
<p>Зв’язність можна обчислити за допомогою функцій <code>node_connectivity()</code> та <code>edge_connectivity()</code>, не вказуючи вихідні та цільові вузли. У наступному прикладі обчислюється зв’язність вузлів для трьох прикладів мереж:</p>
<div id="db106598" class="cell" data-execution_count="131">
<div class="sourceCode cell-code" id="cb222"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>nx.node_connectivity(G_karate)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="131">
<pre><code>1</code></pre>
</div>
</div>
<div id="485a1ef1" class="cell" data-execution_count="132">
<div class="sourceCode cell-code" id="cb224"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>nx.node_connectivity(G_novel)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="132">
<pre><code>1</code></pre>
</div>
</div>
<div id="2047aeea" class="cell" data-execution_count="133">
<div class="sourceCode cell-code" id="cb226"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>nx.node_connectivity(G_woman)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="133">
<pre><code>2</code></pre>
</div>
</div>
<p>Здається, що всі ці мережі, окрім мережі жінок, можна роз’єднати, видаливши лише один вузок. Для мережі жінок потребується видалити два вузли.</p>
<p>Попередня міра зв’язності знаходить розмір найменшого мінімального розрізу, але його видалення не вплине на всі шляхи в мережі. Після видалення вузла або ребра мережа буде розділена, але в кожній половині вузли все ще будуть з’єднані один з одним.</p>
<p>Кращий показник надійності можна знайти, усереднивши зв’язність по всіх вузлах або ребрах за допомогою функцій <code>average_node_connectivity()</code> і <code>average_edge_connectivity()</code>. Зауважте, що обчислення цих значень може зайняти багато часу, навіть для невеликих мереж. Наступний код обчислює середню зв’язність вузлів для досліджуваних мереж:</p>
<div id="b54eb1f1" class="cell" data-execution_count="134">
<div class="sourceCode cell-code" id="cb228"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Середня зв'язність для карате-клубу: "</span>, nx.average_node_connectivity(G_karate))</span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Середня зв'язність для роману: "</span>, nx.average_node_connectivity(G_novel))</span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Середня зв'язність для жінок: "</span>, nx.average_node_connectivity(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Середня зв'язність для карате-клубу:  2.2174688057040997
Середня зв'язність для роману:  2.2624743677375254
Середня зв'язність для жінок:  3.7399193548387095</code></pre>
</div>
</div>
<p>Мережа каратистів та персонажів роману доволі подібні один до одного по зв’язності, але мережа жінок представляється найбільш стійкою або організованою.</p>
</section>
<section id="централізація-та-нерівномірність" class="level4" data-number="13.1.5.5">
<h4 data-number="13.1.5.5" class="anchored" data-anchor-id="централізація-та-нерівномірність"><span class="header-section-number">13.1.5.5</span> Централізація та нерівномірність</h4>
<p>Мережі також можна класифікувати за <strong>ступенем централізації</strong> (centrality) — наскільки вони зосереджені в одному або декількох вузлах. Нерівномірний розподіл є більш централізованим. Наприклад, найбільш централізованою мережею є мережа, всі вузли якої під’єднані до одного вузла-хабу. Наступний код будує гістограми ступенів впливовості для кожної з мереж:</p>
<div id="cell-fig-33" class="cell" data-execution_count="135">
<div class="sourceCode cell-code" id="cb230"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Функція для побудови гістограми</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> centrality_histogram(x, title<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>    plt.hist(x, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Впливовість"</span>)</span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Підрахунок"</span>)</span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Створення рисунку</span></span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Розрахунок центральностей для кожного графа</span></span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb230-12"><a href="#cb230-12" aria-hidden="true" tabindex="-1"></a>centrality_histogram(</span>
<span id="cb230-13"><a href="#cb230-13" aria-hidden="true" tabindex="-1"></a>nx.eigenvector_centrality(G_karate).values(), title<span class="op">=</span><span class="st">"Карате"</span>)</span>
<span id="cb230-14"><a href="#cb230-14" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb230-15"><a href="#cb230-15" aria-hidden="true" tabindex="-1"></a>centrality_histogram(</span>
<span id="cb230-16"><a href="#cb230-16" aria-hidden="true" tabindex="-1"></a>nx.eigenvector_centrality(G_novel).values(),</span>
<span id="cb230-17"><a href="#cb230-17" aria-hidden="true" tabindex="-1"></a>title<span class="op">=</span><span class="st">"Роман"</span>)</span>
<span id="cb230-18"><a href="#cb230-18" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb230-19"><a href="#cb230-19" aria-hidden="true" tabindex="-1"></a>centrality_histogram(</span>
<span id="cb230-20"><a href="#cb230-20" aria-hidden="true" tabindex="-1"></a>nx.eigenvector_centrality(G_woman).values(), title<span class="op">=</span><span class="st">"Жінки"</span>)</span>
<span id="cb230-21"><a href="#cb230-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-22"><a href="#cb230-22" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-33" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-33-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-33-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-33-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.35: Гістограми ступенів впливовості в мережах карате-клубу, персонажів роману та соціальної взаємодії між жінками в містечку на півдні США в 1930-х роках
</figcaption>
</figure>
</div>
</div>
</div>
<p>З представлених гістограм видно, що найвищі значення впливовості приходяться на мережу жінок. Найгіршою за впливовістю є мережа персонажів роману.</p>
<p>Виміряти нерівномірність набору значень можна за допомогою <strong>ентропії Шеннона</strong>. Чим більш рівномірно розподіленим є набір чисел, тим вища його ентропія. Наступна функція повертає ентропію списку чисел:</p>
<div id="4b4a1ff7" class="cell" data-execution_count="136">
<div class="sourceCode cell-code" id="cb231"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> entropy(x):</span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Нормалізація</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(x)</span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> [xi <span class="op">/</span> total <span class="cf">for</span> xi <span class="kw">in</span> x]</span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> <span class="bu">sum</span>([<span class="op">-</span>xi <span class="op">*</span> math.log2(xi) <span class="cf">for</span> xi <span class="kw">in</span> x])</span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> H</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Обчислення ентропії ступенів впливовості у кожній з мереж дає наступний результат:</p>
<div id="b7d1f799" class="cell" data-execution_count="137">
<div class="sourceCode cell-code" id="cb232"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Ентропія ступенів впливовості для карате-клубу: "</span>, </span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>      entropy(nx.eigenvector_centrality(G_karate).values()))</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Ентропія ступенів впливовості для роману: "</span>, </span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>      entropy(nx.eigenvector_centrality(G_novel).values()))</span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Ентропія ступенів впливовості для жінок: "</span>, </span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a>      entropy(nx.eigenvector_centrality(G_woman).values()))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Ентропія ступенів впливовості для карате-клубу:  4.842401948329853
Ентропія ступенів впливовості для роману:  5.52075429881287
Ентропія ступенів впливовості для жінок:  4.858808158743919</code></pre>
</div>
</div>
<p>Найбільш рівномірно розподіленою в даному випадку представляється мережа персонажів роману. Мережі карате-клубу та жінок мають трохи вищий ступінь централізації.</p>
<p>У соціальних мережах не всі стосунки є рівними. У соціології міцність стосунків вимірюється поняттям <strong>міцність зв’язності</strong> (tie strength). У цьому контексті зв’язність — це певний вид міжособистісних стосунків, а міцність — це будь-яка міра того, наскільки інтенсивними чи близькими є ці стосунки (зв’язності).</p>
<p>У 1973 році соціолог Марк Грановеттер описав важливість слабких зв’язків для зближення різних спільнот. Якщо всі зв’язки всередині спільноти сильні, то будь-які зв’язки між спільнотами мають бути слабкими. Він назвав це явище силою слабких зв’язків. З’єднуючи різні спільноти, слабкі зв’язки дають змогу знаходити інформацію з віддалених частин мережі. Але як виміряти силу зв’язностей?</p>
</section>
<section id="сила-звязності" class="level4" data-number="13.1.5.6">
<h4 data-number="13.1.5.6" class="anchored" data-anchor-id="сила-звязності"><span class="header-section-number">13.1.5.6</span> Сила зв’язності</h4>
<p>У мережі карате-клубу немає ніякої додаткової інформації про міцність ребер, але є відповідні властивості цих ребер, які можна обчислити, наприклад, <strong>сила зв’язності</strong>. Сила зв’язності зростає зі збільшенням кількості сусідів, які мають спільні вершини. Це мотивовано спостереженням, що близькі друзі, як правило, мають більше спільних друзів, і це часто може дати уявлення про структуру соціальної мережі. Наступний код обчислює силу зв’язку, використовуючи метод <code>neighbors()</code> для пошуку сусідів вузлів:</p>
<div id="b8b485dd" class="cell" data-execution_count="138">
<div class="sourceCode cell-code" id="cb234"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tie_strength(G, v, w):</span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Отримуємо сусідів вершин v та w у G</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>    v_neighbors <span class="op">=</span> <span class="bu">set</span>(G.neighbors(v))</span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a>    w_neighbors <span class="op">=</span> <span class="bu">set</span>(G.neighbors(w))</span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Повернути розмір заданої зв'язності</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(v_neighbors <span class="op">&amp;</span> w_neighbors)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Тут ми визначили міцність зв’язку як кількість спільних сусідів плюс один. Чому плюс один? Нульова вага умовно означає відсутність ребра, тому без додаткової одиниці ребра між вершинами, які не мають спільних сусідів, не вважатимуться ребрами.</p>
<div id="8028ce45" class="cell" data-execution_count="139">
<div class="sourceCode cell-code" id="cb235"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Надаємо інформацію про те, хто в якому клубі </span></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a><span class="co"># опинився після розділення клубу</span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>member_club <span class="op">=</span> [</span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>,</span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,</span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,</span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-11"><a href="#cb235-11" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G, <span class="bu">dict</span>(<span class="bu">enumerate</span>(member_club)), <span class="st">'club'</span>)</span>
<span id="cb235-12"><a href="#cb235-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-13"><a href="#cb235-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Знаходимо внутрішні та зовнішні ребра</span></span>
<span id="cb235-14"><a href="#cb235-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v, w <span class="kw">in</span> G.edges:</span>
<span id="cb235-15"><a href="#cb235-15" aria-hidden="true" tabindex="-1"></a> <span class="co"># Перебираємо пари вершин</span></span>
<span id="cb235-16"><a href="#cb235-16" aria-hidden="true" tabindex="-1"></a> <span class="co"># Встановлюємо 'True', якщо вершини в одному кластері (клубі)</span></span>
<span id="cb235-17"><a href="#cb235-17" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> G.nodes[v][<span class="st">"club"</span>] <span class="op">==</span> G.nodes[w][<span class="st">"club"</span>]:</span>
<span id="cb235-18"><a href="#cb235-18" aria-hidden="true" tabindex="-1"></a>    G.edges[v, w][<span class="st">"internal"</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb235-19"><a href="#cb235-19" aria-hidden="true" tabindex="-1"></a> <span class="cf">else</span>:</span>
<span id="cb235-20"><a href="#cb235-20" aria-hidden="true" tabindex="-1"></a>    G.edges[v, w][<span class="st">"internal"</span>] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb235-21"><a href="#cb235-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-22"><a href="#cb235-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Внутріші - каратисти знаходяться в одному клубі й підтримують зв'язок</span></span>
<span id="cb235-23"><a href="#cb235-23" aria-hidden="true" tabindex="-1"></a>internal <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> G.edges <span class="cf">if</span> G.edges[e][<span class="st">"internal"</span>]]</span>
<span id="cb235-24"><a href="#cb235-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-25"><a href="#cb235-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Зовнішні - каратисти в різних клубах, але продовжують підтримувати зв'язок</span></span>
<span id="cb235-26"><a href="#cb235-26" aria-hidden="true" tabindex="-1"></a>external <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> G.edges <span class="cf">if</span> <span class="op">~</span>G.edges[e][<span class="st">"internal"</span>]]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Наступний код обчислює силу зв’язності кожного ребра і зберігає її в змінну <code>strength</code>:</p>
<div id="5537a735" class="cell" data-execution_count="140">
<div class="sourceCode cell-code" id="cb236"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>strength <span class="op">=</span> <span class="bu">dict</span>(</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a> ((v,w), tie_strength(G, v, w))</span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">for</span> v, w <span class="kw">in</span> G.edges())</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="мостовий-проліт" class="level4" data-number="13.1.5.7">
<h4 data-number="13.1.5.7" class="anchored" data-anchor-id="мостовий-проліт"><span class="header-section-number">13.1.5.7</span> Мостовий проліт</h4>
<p>Міцність зв’язків також можна оцінити кількісно, розглядаючи ефект видалення ребра з мережі. Вузли, з’єднані ребром, завжди знаходяться на відстані в 1 крок один від одного (у незваженій мережі). Але, якщо це ребро видалити, його кінцеві точки можуть знаходитись на відстані в 2 кроки, і навіть до зовсім не з’єднаних між собою. Цю концепцію відображає <strong>мостовий проліт</strong> (bridge span) — відстань між кінцевими точками ребра, якщо це ребро видалити. Ребра з великим прольотом з’єднують віддалені частини мережі, тому їх можна вважати слабкими зв’язками, незважаючи на те, що вони відіграють важливу роль.</p>
<p>Наступний код обчислює довжину кожного ребра в мережі карате-клубу:</p>
<div id="9c61fbdd" class="cell" data-execution_count="141">
<div class="sourceCode cell-code" id="cb237"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bridge_span(G):</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Отримуємо список ребер</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> G.edges()</span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Створюємо копію графа</span></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.Graph(G)</span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Створюємо словник для збереження результату</span></span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v, w <span class="kw">in</span> edges:</span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Тимчасово видаляємо ребро </span></span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true" tabindex="-1"></a>        G.remove_edge(v, w)</span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Знаходимо нову відстань між двома вузлами </span></span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># після видалення ребра</span></span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb237-14"><a href="#cb237-14" aria-hidden="true" tabindex="-1"></a>            d <span class="op">=</span> nx.shortest_path_length(G, v, w)</span>
<span id="cb237-15"><a href="#cb237-15" aria-hidden="true" tabindex="-1"></a>            result[(v, w)] <span class="op">=</span> d</span>
<span id="cb237-16"><a href="#cb237-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> nx.NetworkXNoPath:</span>
<span id="cb237-17"><a href="#cb237-17" aria-hidden="true" tabindex="-1"></a>            result[(v, w)] <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb237-18"><a href="#cb237-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Відновлюємо ребро</span></span>
<span id="cb237-19"><a href="#cb237-19" aria-hidden="true" tabindex="-1"></a>        G.add_edge(v, w)</span>
<span id="cb237-20"><a href="#cb237-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="69ccc8c8" class="cell" data-execution_count="142">
<div class="sourceCode cell-code" id="cb238"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a>span <span class="op">=</span> bridge_span(G)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="порівняння-міцності-та-прольоту" class="level4" data-number="13.1.5.8">
<h4 data-number="13.1.5.8" class="anchored" data-anchor-id="порівняння-міцності-та-прольоту"><span class="header-section-number">13.1.5.8</span> Порівняння міцності та прольоту</h4>
<p>Розглянемо 10 найміцніших і 10 найслабших ребер у мережі карате-клубу. Наступний код виводить ці ребра:</p>
<div id="91db79a3" class="cell" data-execution_count="143">
<div class="sourceCode cell-code" id="cb239"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Упорядковуємо ребра за силою зв'язності</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a>ordered_edges <span class="op">=</span> <span class="bu">sorted</span>(strength.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])</span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Ребро</span><span class="ch">\t</span><span class="st"> Міцність</span><span class="ch">\t</span><span class="st"> Проліт</span><span class="ch">\t</span><span class="st"> Внутрішній зв</span><span class="ch">\'</span><span class="st">язок'</span>)</span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Виводимо 10 найміцніших</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> e, edge_strength <span class="kw">in</span> ordered_edges[:<span class="dv">10</span>]:</span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'</span><span class="sc">{:10}{}</span><span class="ch">\t\t</span><span class="sc">{}</span><span class="ch">\t</span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">str</span>(e), edge_strength, span[e], G.edges[e][<span class="st">'internal'</span>]))</span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'...'</span>)</span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Виводимо 10 найслабших</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> e, edge_strength <span class="kw">in</span> ordered_edges[<span class="op">-</span><span class="dv">10</span>:]:</span>
<span id="cb239-11"><a href="#cb239-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'</span><span class="sc">{:10}{}</span><span class="ch">\t\t</span><span class="sc">{}</span><span class="ch">\t</span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb239-12"><a href="#cb239-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">str</span>(e), edge_strength, span[e], G.edges[e][<span class="st">'internal'</span>]))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Ребро    Міцність    Проліт  Внутрішній зв'язок
(0, 11)   1     inf True
(0, 31)   1     3   False
(1, 30)   1     3   False
(2, 9)    1     3   False
(2, 27)   1     3   False
(2, 28)   1     3   False
(9, 33)   1     3   True
(13, 33)  1     3   False
(19, 33)  1     3   False
(23, 25)  1     3   True
...
(8, 32)   4     2   True
(23, 33)  4     2   True
(29, 33)  4     2   True
(1, 2)    5     2   True
(1, 3)    5     2   True
(2, 3)    5     2   True
(0, 2)    6     2   True
(0, 3)    6     2   True
(0, 1)    8     2   True
(32, 33)  11        2   True</code></pre>
</div>
</div>
<p>Результат показує, що ребра з низькою міцністю і великим прольотом, як правило, є зовнішніми, з’єднуючи членів клубу, які розкололися на різні клуби-відколи. З іншого боку, ребра з високою міцністю і малим прольотом є внутрішніми, вони з’єднують членів клубу, які залишилися разом після розколу.</p>
</section>
<section id="спектральні-міри-складності" class="level4" data-number="13.1.5.9">
<h4 data-number="13.1.5.9" class="anchored" data-anchor-id="спектральні-міри-складності"><span class="header-section-number">13.1.5.9</span> Спектральні міри складності</h4>
<p><strong>Спектром графа</strong> <span class="math inline">\(G\)</span> називається множина власних значень матриці, що відповідає даному графу. Відомі декілька підходів встановлення зв’язку між графом <span class="math inline">\(G\)</span> та його спектром. Для випадку регулярних графів (якими є графи часових рядів фондових індексів) можна показати, що різні види спектрів еквівалентні, тобто містять однакову кількість інформації щодо структури графа <span class="math inline">\(G\)</span>.</p>
<p>Ми вже згадували, що одним із способів представлення графа у вигляді матриці є матриця суміжності. <strong>Матриця Лапласа</strong> (Laplacian matrix) <span class="math inline">\(L\)</span> — також є одним видів подання графа. Вона може бути використана для розрахунку кількості остовних дерев для графа. Для знаходження матриці Лапласа використовують формулу <span class="math inline">\(L=D-A\)</span>, де <span class="math inline">\(D\)</span> — діагональна матриця:</p>
<p><span class="math display">\[
d_{ij} = \begin{cases}
            d_i, &amp; i=j,\\
            0, &amp; i \neq j,
        \end{cases}
\]</span></p>
<p>де <span class="math inline">\(d_i\)</span> — ступінь відповідної вершини графа. Отже,</p>
<p><span class="math display">\[
l_{ij} = \begin{cases}
    d_i, &amp; i=j, \\
    -1, &amp; i \neq j \, \text{і} \, v_i \, \text{суміжна з} \, v_j, \\
    0 &amp; \text{в іншому випадку}.
\end{cases}
\]</span></p>
<p><strong>Алгебраїчна зв’язність графа</strong> (algebraic connectivity) — друге найменше власне значення матриці Лапласа. Це власне значення більше нуля тоді і тільки тоді, коли граф зв’язний. Величина цього значення відображає, наскільки зв’язним є даний граф, і використовується при аналізі надійності та синхронізації мереж. Бібліотека <code>NetworkX</code> містить метод <code>algebraic_connectivity()</code> для обчислення даного показника. Бібліотека також надає змогу розрахувати нормалізовану матрицю Лапласа. Сенс нормалізації полягає в тому, що вершина з великим ступенем вершини, яку також називають <strong>важкою вершиною</strong>, призводить до того, що в матриці Лапласа з’являється великий діагональний елемент, який домінує у властивостях матриці. Нормалізація спрямована на те, щоб зробити вплив таких вершин більш рівним впливу інших вершин шляхом ділення елементів матриці Лапласа на ступені вершин. Щоб уникнути ділення на нуль, ізольовані вершини з нульовими ступенями виключаються з процесу нормалізації.</p>
<div id="78e6a881" class="cell" data-execution_count="144">
<div class="sourceCode cell-code" id="cb241"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Алгебраїчна зв'язність для карате-клубу: "</span>, nx.algebraic_connectivity(G_karate, normalized<span class="op">=</span><span class="va">True</span>, method<span class="op">=</span><span class="st">'tracemin_lu'</span>))</span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Алгебраїчна зв'язність для роману: "</span>, nx.algebraic_connectivity(G_novel, normalized<span class="op">=</span><span class="va">True</span>, method<span class="op">=</span><span class="st">'tracemin_lu'</span>))</span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Алгебраїчна зв'язність для жінок: "</span>, nx.algebraic_connectivity(G_woman, normalized<span class="op">=</span><span class="va">True</span>, method<span class="op">=</span><span class="st">'tracemin_lu'</span>))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Алгебраїчна зв'язність для карате-клубу:  0.11007419200657863
Алгебраїчна зв'язність для роману:  0.06737737553000264
Алгебраїчна зв'язність для жінок:  0.2079721479691762</code></pre>
</div>
</div>
<p>Можемо бачити, що найбільш зв’язним у даному випадку представляється саме граф жінок. Тобто спілкування та кооперація між ними залишається найбільш тісною.</p>
<p><strong>Енергія графа</strong> (graph energy) — це сума абсолютних значень власних значень матриці суміжності графа. Нехай <span class="math inline">\(G\)</span> є граф з <span class="math inline">\(n\)</span> вершинами. Передбачається, що <span class="math inline">\(G\)</span> — простий, тобто він не містить петлі чи паралельних ребер. Нехай <span class="math inline">\(A\)</span> — матриця суміжності графа <span class="math inline">\(G\)</span> і <span class="math inline">\(\lambda_i\)</span>, <span class="math inline">\(i=1,...,n\)</span> — власні значення матриці <span class="math inline">\(A\)</span>. Тоді енергія графа визначається як:</p>
<p><span class="math display">\[
E(G) = \sum_{i=1}^{n}\left| \lambda_i \right|.
\]</span></p>
<p>Вбудованого методу в <code>NetworkX</code> для визначення енергії графа немає, але ми доволі запросто можемо розрахувати спектр власних значень матриці суміжності, а потім скористатися формулою вище. Власні значення матриці <span class="math inline">\(A\)</span> можна знайти за допомогою методу <code>adjacency_spectrum()</code>. Далі визначимо наступну функцію для розрахунку енергії графа:</p>
<div id="48dbdb9f" class="cell" data-execution_count="145">
<div class="sourceCode cell-code" id="cb243"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> graph_energy(G): </span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a>    adj_spectrum <span class="op">=</span> nx.adjacency_spectrum(G) <span class="co"># спектр власних значень матриці суміжності</span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a>    graph_en <span class="op">=</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(adj_spectrum))</span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph_en</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Тепер розрахуємо енергію для кожного досліджуваного графа:</p>
<div id="6bd29bca" class="cell" data-execution_count="146">
<div class="sourceCode cell-code" id="cb244"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Енергія графа карате-клубу: "</span>, graph_energy(G_karate))</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Енергія графа роману: "</span>, graph_energy(G_novel))</span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Енергія графа жінок: "</span>, graph_energy(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Енергія графа карате-клубу:  153.22817810462595
Енергія графа роману:  460.4651813130986
Енергія графа жінок:  51.82012198561654</code></pre>
</div>
</div>
<p>Найвище значення енергії графа вказує на найвищу складність мережі або на найвищий ступінь централізованості деяких вузлів. Для наших графів видно, що найвища енергія приходить саме граф персонажів роману. Тобто, тут є декілька персонажів, на які приходить найбільша кількість зв’язків (діалогів) у порівнянні з іншими персонажами.</p>
<p><strong>Спектральний розрив</strong> (spectral gap) — різниця між найбільшим і другим за величиною власними значеннями, надає інформацію про те, як швидко досягається синхронний стан. Можемо визначити й прорахувати наступну функцію:</p>
<div id="19c1f2dd" class="cell" data-execution_count="147">
<div class="sourceCode cell-code" id="cb246"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spectral_gap(G):</span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>    adj_spectrum <span class="op">=</span> nx.adjacency_spectrum(G)</span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>    sorted_adj_spectrum <span class="op">=</span> np.sort(adj_spectrum.real)</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>    spec_gap <span class="op">=</span> sorted_adj_spectrum[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> sorted_adj_spectrum[<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> spec_gap</span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний розрив для карате-клубу: "</span>, spectral_gap(G_karate))</span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний розрив для роману: "</span>, spectral_gap(G_novel))</span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний розрив для жінок: "</span>, spectral_gap(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Спектральний розрив для карате-клубу:  4.58124582340616
Спектральний розрив для роману:  16.258106786753928
Спектральний розрив для жінок:  2.3618098280048976</code></pre>
</div>
</div>
<p><strong>Спектральний радіус</strong> (spectral radius) є найбільшим за модулем власним значенням:</p>
<p><span class="math display">\[
r(A) = \max_{\lambda \in Spec(A)} \left| \lambda \right|,
\]</span></p>
<p>де <span class="math inline">\(Spec(A)\)</span> — спектр власних значень матриці суміжності. Для розрахунків визначимо наступну функцію:</p>
<div id="bfc4e1f1" class="cell" data-execution_count="148">
<div class="sourceCode cell-code" id="cb248"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spectral_radius(G): </span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>    adj_spectrum <span class="op">=</span> nx.adjacency_spectrum(G).real</span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>    spec_rad <span class="op">=</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(adj_spectrum))</span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> spec_rad</span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний радіус для карате-клубу: "</span>, spectral_radius(G_karate))</span>
<span id="cb248-8"><a href="#cb248-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний радіус для роману: "</span>, spectral_radius(G_novel))</span>
<span id="cb248-9"><a href="#cb248-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний радіус для жінок: "</span>, spectral_radius(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Спектральний радіус для карате-клубу:  21.687565903954198
Спектральний радіус для роману:  65.0262803552607
Спектральний радіус для жінок:  6.741908124910325</code></pre>
</div>
</div>
<p><strong>Спектральний момент</strong> (spectral moment). Для визначення <span class="math inline">\(k\)</span>-ого спектрального моменту використовують матрицю суміжності. Визначимо її наступним чином:</p>
<p><span class="math display">\[
m_k(A)=\frac{1}{n}\sum_{i=1}^{n}\lambda_{i}^{k},
\]</span></p>
<p>де <span class="math inline">\(\lambda_i\)</span> — власні значення матриці суміжності <span class="math inline">\(A\)</span>, <span class="math inline">\(n\)</span> — кількість вершин графа <span class="math inline">\(G\)</span>. Значення <span class="math inline">\(k\)</span> у нашому випадку випадку буде дорівнювати 3. Тобто, будемо обчислювати спектральний момент 3-го порядку. Визначимо наступну функцію для розрахунку даного показника:</p>
<div id="33c7ec5e" class="cell" data-execution_count="149">
<div class="sourceCode cell-code" id="cb250"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spectral_moment(G):</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>    adj_spectrum <span class="op">=</span> nx.adjacency_spectrum(G).real</span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>    spec_mom_3 <span class="op">=</span> np.mean(adj_spectrum <span class="op">**</span> <span class="dv">3</span>)</span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> spec_mom_3</span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний момент для карате-клубу: "</span>, spectral_moment(G_karate))</span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний момент для роману: "</span>, spectral_moment(G_novel))</span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Спектральний момент для жінок: "</span>, spectral_moment(G_woman))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Спектральний момент для карате-клубу:  321.3529411764713
Спектральний момент для роману:  4325.688311688335
Спектральний момент для жінок:  1.1585177261963508e-13</code></pre>
</div>
</div>
<p>Останні показники говорять по те, що персонажі роману характеризуються найвищим ступенем складності в порівнянні з іншими графами. Ми показали, що достатня кількість вузлів має досить невисокий найкоротший шлях, але може мати гіршу щільність зв’язності вузлів або рівнорозподіленності ступеня впливовості.</p>
</section>
<section id="проблема-малого-світу" class="level4" data-number="13.1.5.10">
<h4 data-number="13.1.5.10" class="anchored" data-anchor-id="проблема-малого-світу"><span class="header-section-number">13.1.5.10</span> Проблема малого світу</h4>
<p>У 1967 році соціальні психологи Джеффрі Треверс і Стенлі Мілґрем надіслали листи групам людей у Вічіті, штат Канзас, та Омасі, штат Небраска. Вони також обрали одну цільову особу в штаті Массачусетс. Кожному отримувачу листа було доручено переслати його знайомому, який, найімовірніше, знав цільову людину. Багато листів дійшли до адресата, і дослідники змогли з’ясувати, скільки кроків було зроблено для цього. Середня кількість кроків становила шість, звідси і поширена фраза “шість ступенів відокремлення” <span class="citation" data-cites="TRAVERS1977179">&nbsp;[<a href="references.html#ref-TRAVERS1977179" role="doc-biblioref">6</a>]</span>.</p>
</section>
<section id="кільцеві-мережі" class="level4" data-number="13.1.5.11">
<h4 data-number="13.1.5.11" class="anchored" data-anchor-id="кільцеві-мережі"><span class="header-section-number">13.1.5.11</span> Кільцеві мережі</h4>
<p>Як правило, більшість знайомих людини — це люди, які живуть у тій самій місцевості. Якби кожна людина була знайома лише з тими, хто живе поруч, то можна було б очікувати, що для того, щоб надіслати повідомлення з Канзасу до Массачусетсу, знадобилося б більше шести кроків, оскільки кожен крок міг би подолати лише невелику відстань. Таку мережу можна змоделювати як кільце: вузли, розташовані по колу, причому кожен вузол з’єднаний з найближчими <span class="math inline">\(k/2\)</span> вузлами з кожного боку. Наступний приклад створює та візуалізує чотирикільце за допомогою функції <code>watts_strogatz_graph()</code> про яку ми ще поговоримо.</p>
<div id="cell-fig-34" class="cell" data-execution_count="150">
<div class="sourceCode cell-code" id="cb252"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>G_small_ring <span class="op">=</span> nx.watts_strogatz_graph(<span class="dv">16</span>, <span class="dv">4</span>, <span class="dv">0</span>)</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.circular_layout(G_small_ring)</span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_small_ring, pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">False</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-34" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-34-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-34-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-34-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.36: Кільцеве представлення графа Воттса-Строгаца
</figcaption>
</figure>
</div>
</div>
</div>
<p>Щоб з’єднати два вузли в попередньому прикладі, потрібно пройти по краю кола, пропускаючи щонайбільше кожен другий вузол. Навіть у цій дуже маленькій мережі типова мережна відстань є досить великою.</p>
<p>Наступний код знаходить середній найкоротший шлях і середню кластеризацію в більш реалістичному 10-ти кільцевому графі з 4000 вузлів:</p>
<div id="9057c583" class="cell" data-execution_count="151">
<div class="sourceCode cell-code" id="cb253"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>G_ring <span class="op">=</span> nx.watts_strogatz_graph(<span class="dv">4000</span>, <span class="dv">10</span>, <span class="dv">0</span>)</span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>nx.average_shortest_path_length(G_ring)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="151">
<pre><code>200.45011252813202</code></pre>
</div>
</div>
<div id="43cff0bc" class="cell" data-execution_count="152">
<div class="sourceCode cell-code" id="cb255"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>nx.average_clustering(G_ring)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="152">
<pre><code>0.6666666666666546</code></pre>
</div>
</div>
<p>Ця мережа має в середньому 200 кроків розділення, що набагато більше, ніж шість! Вона також має досить великий середній коефіцієнт кластеризації 0.67, що показує, що сусіди вузла мають тенденцію бути пов’язаними один з одним.</p>
</section>
<section id="випадкові-мережі" class="level4" data-number="13.1.5.12">
<h4 data-number="13.1.5.12" class="anchored" data-anchor-id="випадкові-мережі"><span class="header-section-number">13.1.5.12</span> Випадкові мережі</h4>
<p>Щоб дослідити цю таємницю, розглянемо інший тип мережі. У цій мережі ми починаємо з <span class="math inline">\(k\)</span>-кільця, але випадковим чином переставляємо кінцеві точки кожного ребра. В результаті отримаємо мережу з тією ж кількістю вузлів і ребер, але з випадковою структурою, що демонструється наступним кодом:</p>
<div id="cell-fig-35" class="cell" data-execution_count="153">
<div class="sourceCode cell-code" id="cb257"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a>G_small_random <span class="op">=</span> nx.watts_strogatz_graph(<span class="dv">16</span>, <span class="dv">4</span>, <span class="dv">1</span>)</span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.circular_layout(G_small_random)</span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_small_random, pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">False</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-35" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-35-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-35-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-35-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.37: Кільцеве представлення графа Воттса-Строгаца з випадковим перев’язуванням ребер
</figcaption>
</figure>
</div>
</div>
</div>
<p>Тепер давайте розглянемо властивості перев’язаного 10-ти кільцевого графа з 4000 вузлів:</p>
<div id="47cfa8be" class="cell" data-execution_count="154">
<div class="sourceCode cell-code" id="cb258"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>G_random <span class="op">=</span> nx.watts_strogatz_graph(<span class="dv">4000</span>, <span class="dv">10</span>, <span class="dv">1</span>)</span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>nx.average_shortest_path_length(G_random)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="154">
<pre><code>3.867028507126782</code></pre>
</div>
</div>
<div id="a9fca4f1" class="cell" data-execution_count="155">
<div class="sourceCode cell-code" id="cb260"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>nx.average_clustering(G_random)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="155">
<pre><code>0.0020522294183284917</code></pre>
</div>
</div>
<p>Середній найкоротший шлях дуже близький до реальної соціальної мережі, але середня кластеризація тепер майже 0. Поки що моделі, які ми бачили, досягають коротких шляхів або високої кластеризації, але не того й іншого разом.</p>
</section>
<section id="мережа-воттса-строгаца" class="level4" data-number="13.1.5.13">
<h4 data-number="13.1.5.13" class="anchored" data-anchor-id="мережа-воттса-строгаца"><span class="header-section-number">13.1.5.13</span> Мережа Воттса-Строгаца</h4>
<p>Проблема малого світу полягає в тому, як люди, що живуть на великій відстані один від одного, можуть бути пов’язані короткими шляхами, навіть якщо їхні зв’язки є локальними. Дункан Воттс і Стівен Строгац розробили клас мереж для пояснення такої поведінки. Мережі починаються як <span class="math inline">\(k\)</span>-кільця: вузли, розміщені по колу, кожен з яких з’єднаний з найближчими <span class="math inline">\(k\)</span> сусідами. Потім, з ймовірністю <span class="math inline">\(p\)</span>, ребра кожного вузла перев’язуються з іншим випадково обраним вузлом. Ці перестановки створюють короткі шляхи по всій мережі. Навіть невелика кількість коротких шляхів значно скорочує відстані між вузлами мережі, вирішуючи проблему малого світу. Фактично, це саме те, що робить функція <code>watts_strogatz_graph()</code>, яку ми використовували, а третій параметр задає частку ребер, які потрібно перезв’язати. Наступний код обчислює середній найкоротший шлях і середню кластеризацію для діапазону ймовірностей перезв’язування:</p>
<div id="a2c5475f" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb262"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> []</span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a>clustering <span class="op">=</span> []</span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Пробуємо список імовірностей перезв'язування</span></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> [<span class="dv">10</span><span class="op">**</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">6</span>, <span class="dv">1</span>)]</span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p_i <span class="kw">in</span> p:</span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true" tabindex="-1"></a>    path_i <span class="op">=</span> []</span>
<span id="cb262-7"><a href="#cb262-7" aria-hidden="true" tabindex="-1"></a>    clustering_i <span class="op">=</span>[]</span>
<span id="cb262-8"><a href="#cb262-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Створюємо 10 моделей для кожної ймовірності</span></span>
<span id="cb262-9"><a href="#cb262-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb262-10"><a href="#cb262-10" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> nx.watts_strogatz_graph(<span class="dv">1000</span>, <span class="dv">10</span>, p_i)</span>
<span id="cb262-11"><a href="#cb262-11" aria-hidden="true" tabindex="-1"></a>        path_i.append(nx.average_shortest_path_length(G))</span>
<span id="cb262-12"><a href="#cb262-12" aria-hidden="true" tabindex="-1"></a>        clustering_i.append(nx.average_clustering(G))</span>
<span id="cb262-13"><a href="#cb262-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Усереднюємо показники для кожного значення p_i</span></span>
<span id="cb262-14"><a href="#cb262-14" aria-hidden="true" tabindex="-1"></a>    path.append(<span class="bu">sum</span>(path_i) <span class="op">/</span> <span class="bu">len</span>(path_i))</span>
<span id="cb262-15"><a href="#cb262-15" aria-hidden="true" tabindex="-1"></a>    clustering.append(<span class="bu">sum</span>(clustering_i) <span class="op">/</span> <span class="bu">len</span>(clustering_i))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Результати наступного коду зберігаються у списках <code>path</code> та <code>clustering</code>. Використовуючи функцію <code>semilogx()</code> з <code>matplotlib.pyplot</code>, наступний код візуалізує, як ці значення змінюються при зміні ймовірності перев’язування від 0 до 1:</p>
<div id="cell-fig-36" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb263"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>plt.semilogx(p, [x <span class="op">/</span> path[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> path], label<span class="op">=</span><span class="vs">r'$L_</span><span class="sc">{mean}</span><span class="vs"> / L_0$'</span>)</span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a>plt.semilogx(p, [x <span class="op">/</span> clustering[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> clustering], label<span class="op">=</span><span class="vs">r'$C_</span><span class="sc">{mean}</span><span class="vs"> / C_0$'</span>)</span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a>plt.tick_params(axis<span class="op">=</span><span class="st">'both'</span>, which<span class="op">=</span><span class="st">'major'</span>)</span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Імовірність перев'язування $p$"</span>)</span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a>plt.legend()<span class="op">;</span> </span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-36" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-36-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-36-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-36-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.38: Зміна відносного середнього найкоротшого шляху та коефіцієнту кластеризації від імовірності перев’язування графа
</figcaption>
</figure>
</div>
</div>
</div>
<p>Як ми вже бачили, зі збільшенням кількості перезв’язувань, як середня кластеризація, так і середній найкоротший шлях зменшуються. Однак цікава річ відбувається при проміжних значеннях. Довжина шляху стає коротшою при дуже низьких значеннях перезв’язування, в той час як зменшення кластеризації відбувається лише при більших значеннях перезв’язування. Іншими словами, перезв’язування дуже малої частки ребер створює “мости”, які з’єднують віддалені частини мережі і різко скорочують середній найкоротший шлях, не змінюючи при цьому кластеризацію. Можна сказати, що найкращий тип мереж це той, що зберігає як частку впорядкованості, так і частку випадковості.</p>
<p>Далі можемо подивитись, як виглядає мережа Воттса й Строгаца при наступних імовірностях: <span class="math inline">\(p=0\)</span>, <span class="math inline">\(p=0.1\)</span> та <span class="math inline">\(p=1\)</span>.</p>
<div id="cell-fig-37" class="cell" data-execution_count="160">
<div class="sourceCode cell-code" id="cb264"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">0.0</span>, <span class="fl">0.1</span>, <span class="fl">1.0</span>]):</span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Генеруємо граф</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.watts_strogatz_graph(<span class="dv">12</span>, <span class="dv">6</span>, p)</span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Будуємо рисунок</span></span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> nx.circular_layout(G)</span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true" tabindex="-1"></a>    nx.draw_networkx(G, pos<span class="op">=</span>pos)</span>
<span id="cb264-9"><a href="#cb264-9" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">"p = </span><span class="sc">{:0.1f}</span><span class="st">"</span>.<span class="bu">format</span>(p))</span>
<span id="cb264-10"><a href="#cb264-10" aria-hidden="true" tabindex="-1"></a>    </span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-37" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-37-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-37-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-37-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.39: Представлення графа Воттса й Строгаца при різних імовірностях перев’язування ребер
</figcaption>
</figure>
</div>
</div>
</div>
<p>У деяких випадках перезв’язування може призвести до того, що дві компоненти в мережі Воттса-Строгаца будуть роз’єднані. Роз’єднана мережа може бути непотрібним ускладненням. Мережа Ньюмана-Воттса-Строгаца — це варіант, який гарантує, що отримана мережа буде зв’язною. Вона схожа на оригінальну версію, але залишає копію оригінального ребра на місці кожного ребра, що перезв’язується. Такі мережі можна створювати за допомогою функції <code>newman_watts_strogatz_graph()</code>, як показано нижче:</p>
<div id="cell-fig-38" class="cell" data-execution_count="161">
<div class="sourceCode cell-code" id="cb265"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">0.0</span>, <span class="fl">0.1</span>, <span class="fl">1.0</span>]):</span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.newman_watts_strogatz_graph(<span class="dv">12</span>, <span class="dv">6</span>, p)</span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> nx.circular_layout(G)</span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true" tabindex="-1"></a>    nx.draw_networkx(G, pos<span class="op">=</span>pos)</span>
<span id="cb265-9"><a href="#cb265-9" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">"p = </span><span class="sc">{:0.1f}</span><span class="st">"</span>.<span class="bu">format</span>(p))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-38" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-38-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-38-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-38-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.40: Представлення графа Ньюмана-Воттса-Строгаца при різних імовірностях перезв’язування ребер
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="степеневі-закони-та-переважне-приєднання" class="level4" data-number="13.1.5.14">
<h4 data-number="13.1.5.14" class="anchored" data-anchor-id="степеневі-закони-та-переважне-приєднання"><span class="header-section-number">13.1.5.14</span> Степеневі закони та переважне приєднання</h4>
<p>Від інтернету до поїздок в аеропорт, багато мереж характеризуються кількома вузлами з великою кількістю зв’язків і багатьма вузлами з дуже малою кількістю зв’язків. Такі мережі характеризуються <strong>важкими хвостами</strong>, тому що при побудові гістограми ступенів вузлів, вузли з високим рівнем зв’язності утворюють хвіст.</p>
<p>Існує багато способів генерування мереж з важким хвостом, але одним з найпоширеніших є модель <strong>переважного приєднання</strong> Барабаші-Альберт. Модель переважного приєднання імітує процеси, в яких багаті стають багатшими. Кожного разу, коли додається новий вузол, він випадковим чином з’єднується з існуючими вузлами, причому більш вірогідним є з’єднання з вузлами високого ступеня.</p>
<p>У NetworkX функція <code>barabasi_albert_graph()</code>, яка генерує мережі переважного приєднання. У наступному коді показано приклад такої мережі з 35 вузлами:</p>
<div id="cell-fig-39" class="cell" data-execution_count="163">
<div class="sourceCode cell-code" id="cb266"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a>G_preferential_35 <span class="op">=</span> nx.barabasi_albert_graph(<span class="dv">35</span>, <span class="dv">1</span>)</span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_preferential_35, k<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_preferential_35, pos)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-39" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-39-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-39-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-39-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.41: Представлення графа переважного приєднання Барабаші-Альберт при 35 вузлах
</figcaption>
</figure>
</div>
</div>
</div>
<p>Структура мережі переважного приєднання ще більш очевидна при більшій кількості вузлів. У наступному прикладі використовується 1000 вузлів:</p>
<div id="cell-fig-40" class="cell" data-execution_count="164">
<div class="sourceCode cell-code" id="cb267"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a>G_preferential_1000 <span class="op">=</span> nx.barabasi_albert_graph(<span class="dv">1000</span>, <span class="dv">1</span>)</span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_preferential_1000)</span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G_preferential_1000, pos, node_size<span class="op">=</span><span class="dv">0</span>, with_labels<span class="op">=</span><span class="va">False</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-40" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-40-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-40-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-40-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.42: Представлення графа переважного приєднання Барабаші-Альберт при 1000 вузлах
</figcaption>
</figure>
</div>
</div>
</div>
<p>Важкі хвости цих мереж можна побачити, побудувавши їхні ступеневі розподіли. Наступна функція будує розподіл ступенів мережі:</p>
<div id="294a4678" class="cell" data-execution_count="165">
<div class="sourceCode cell-code" id="cb268"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_degree_hist(G, title):</span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Функція для побудови розподілу ступенів вершин мережі"""</span></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>    plt.hist(<span class="bu">dict</span>(nx.degree(G)).values(), bins<span class="op">=</span><span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">11</span>))</span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Ступінь'</span>)</span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Щільність'</span>)</span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Використовуючи цю функцію, наступний код візуалізує розподіл ступенів для 35-вузлової та 1000-вузлових мереж переважного приєднання:</p>
<div id="cell-fig-41" class="cell" data-execution_count="166">
<div class="sourceCode cell-code" id="cb269"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a>plot_degree_hist(G_preferential_35, <span class="st">'35 вузлів'</span>)</span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> spine <span class="kw">in</span> ax.spines.values():</span>
<span id="cb269-5"><a href="#cb269-5" aria-hidden="true" tabindex="-1"></a>    spine.set_visible(<span class="va">True</span>)</span>
<span id="cb269-6"><a href="#cb269-6" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb269-7"><a href="#cb269-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> spine <span class="kw">in</span> ax.spines.values():</span>
<span id="cb269-8"><a href="#cb269-8" aria-hidden="true" tabindex="-1"></a>    spine.set_visible(<span class="va">True</span>)</span>
<span id="cb269-9"><a href="#cb269-9" aria-hidden="true" tabindex="-1"></a>plot_degree_hist(G_preferential_1000, <span class="st">'1000 вузлів'</span>)</span>
<span id="cb269-10"><a href="#cb269-10" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-41" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-41-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-41-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-41-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.43: Гістограми ступенів вершини графів переважного приєднання при 35 та 1000 вершинах
</figcaption>
</figure>
</div>
</div>
</div>
<p>Мережі з переважним приєднанням мають одну цікаву властивість: вони <strong>масштабно-інваріантні</strong>. Розподіл ступенів у масштабоінваріантних мережах підпорядковується степеневому закону, що призводить до схожої структури на різних масштабах. Один із способів побачити це — порівняти попередні гістограми. Незважаючи на дуже різні масштаби, вони мають схожу форму. Розподіл ступенів вершин можна описати степеневою функцією виду:</p>
<p><span class="math display">\[
P(k) \propto k^{-\gamma},
\]</span></p>
<p>де <span class="math inline">\(k\)</span> — ступінь вузла, <span class="math inline">\(P(k)\)</span> — ймовірність того, що вузол має ступінь <span class="math inline">\(k\)</span>, і <span class="math inline">\(\gamma\)</span> — показник степеневого закону. Показник <span class="math inline">\(\gamma\)</span> зазвичай знаходиться в діапазоні від 2 до 3 для більшості реальних мереж.</p>
<p>Розподіл ступенів степеневого закону має важливі наслідки для структури та функцій мереж. Наприклад, мережі зі степеневим розподілом часто є більш надійними і стійкими до випадкових збоїв, але більш вразливими до цілеспрямованих атак на вузли з високим ступенем.</p>
</section>
</section>
</section>
<section id="хід-роботи" class="level2" data-number="13.2">
<h2 data-number="13.2" class="anchored" data-anchor-id="хід-роботи"><span class="header-section-number">13.2</span> Хід роботи</h2>
<p>Тепер давайте проведемо порівняльний аналіз графів різної складності з використанням деяких із зазначених показників. За допомогою бібліотеки <code>NetworkX</code> розглянемо наступні типи графів:</p>
<ul>
<li>лінійний граф — <code>path_graph()</code>;</li>
<li>циклічний граф — <code>cycle_graph()</code>;</li>
<li>граф-зірка — <code>star_graph()</code>;</li>
<li>граф Ердеша-Реньї — <code>erdos_renyi_graph()</code>;</li>
<li>граф малого світу — <code>watts_strogatz_graph()</code>;</li>
<li>граф переважного приєднання — <code>barabasi_albert_graph()</code>.</li>
</ul>
<p>Візуалізуємо кожен із зазначених графів:</p>
<div id="cell-fig-42" class="cell" data-execution_count="167">
<div class="sourceCode cell-code" id="cb270"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="co"># лінія </span></span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Лінія'</span>)</span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a>line_graph <span class="op">=</span> nx.path_graph(<span class="dv">100</span>)</span>
<span id="cb270-6"><a href="#cb270-6" aria-hidden="true" tabindex="-1"></a>pos_line_graph <span class="op">=</span> nx.spring_layout(line_graph, k<span class="op">=</span><span class="fl">0.15</span>, iterations<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb270-7"><a href="#cb270-7" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(line_graph, pos<span class="op">=</span>pos_line_graph, node_size<span class="op">=</span><span class="dv">10</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb270-8"><a href="#cb270-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-9"><a href="#cb270-9" aria-hidden="true" tabindex="-1"></a><span class="co"># коло </span></span>
<span id="cb270-10"><a href="#cb270-10" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Коло'</span>)</span>
<span id="cb270-11"><a href="#cb270-11" aria-hidden="true" tabindex="-1"></a>cycle_graph <span class="op">=</span> nx.cycle_graph(<span class="dv">100</span>)</span>
<span id="cb270-12"><a href="#cb270-12" aria-hidden="true" tabindex="-1"></a>pos_cycle_graph <span class="op">=</span> nx.circular_layout(cycle_graph)</span>
<span id="cb270-13"><a href="#cb270-13" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(cycle_graph, pos<span class="op">=</span>pos_cycle_graph, node_size<span class="op">=</span><span class="dv">10</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb270-14"><a href="#cb270-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-15"><a href="#cb270-15" aria-hidden="true" tabindex="-1"></a><span class="co"># зірка</span></span>
<span id="cb270-16"><a href="#cb270-16" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Зірка'</span>)</span>
<span id="cb270-17"><a href="#cb270-17" aria-hidden="true" tabindex="-1"></a>star_graph <span class="op">=</span> nx.star_graph(<span class="dv">100</span>)</span>
<span id="cb270-18"><a href="#cb270-18" aria-hidden="true" tabindex="-1"></a>pos_star_graph <span class="op">=</span> nx.spring_layout(star_graph, k<span class="op">=</span><span class="fl">0.15</span>, iterations<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb270-19"><a href="#cb270-19" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(star_graph, pos<span class="op">=</span>pos_star_graph, node_size<span class="op">=</span><span class="dv">10</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb270-20"><a href="#cb270-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-21"><a href="#cb270-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Ердеша-Реньї</span></span>
<span id="cb270-22"><a href="#cb270-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Ердеш-Реньї'</span>)</span>
<span id="cb270-23"><a href="#cb270-23" aria-hidden="true" tabindex="-1"></a>erdos_renyi_graph <span class="op">=</span> nx.erdos_renyi_graph(<span class="dv">100</span>, <span class="fl">0.01</span>)</span>
<span id="cb270-24"><a href="#cb270-24" aria-hidden="true" tabindex="-1"></a>pos_erdos_renyi_graph <span class="op">=</span> nx.circular_layout(erdos_renyi_graph)</span>
<span id="cb270-25"><a href="#cb270-25" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(erdos_renyi_graph, pos<span class="op">=</span>pos_erdos_renyi_graph, node_size<span class="op">=</span><span class="dv">10</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb270-26"><a href="#cb270-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-27"><a href="#cb270-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Малий світ </span></span>
<span id="cb270-28"><a href="#cb270-28" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Малий світ'</span>)</span>
<span id="cb270-29"><a href="#cb270-29" aria-hidden="true" tabindex="-1"></a>small_world_graph <span class="op">=</span> nx.watts_strogatz_graph(<span class="dv">100</span>, <span class="dv">30</span>, <span class="fl">0.01</span>, seed<span class="op">=</span><span class="dv">32</span>)</span>
<span id="cb270-30"><a href="#cb270-30" aria-hidden="true" tabindex="-1"></a>pos_small_world_graph <span class="op">=</span> nx.spring_layout(small_world_graph, k<span class="op">=</span><span class="fl">0.15</span>, iterations<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb270-31"><a href="#cb270-31" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(small_world_graph, pos<span class="op">=</span>pos_small_world_graph, node_size<span class="op">=</span><span class="dv">10</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>axes[<span class="dv">2</span>, <span class="dv">0</span>])</span>
<span id="cb270-32"><a href="#cb270-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-33"><a href="#cb270-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Переважне приєднання </span></span>
<span id="cb270-34"><a href="#cb270-34" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Переважне приєднання'</span>)</span>
<span id="cb270-35"><a href="#cb270-35" aria-hidden="true" tabindex="-1"></a>barabasi_albert_graph <span class="op">=</span> nx.barabasi_albert_graph(<span class="dv">100</span>, <span class="dv">30</span>, seed<span class="op">=</span><span class="dv">32</span>)</span>
<span id="cb270-36"><a href="#cb270-36" aria-hidden="true" tabindex="-1"></a>pos_barabasi_albert_graph <span class="op">=</span> nx.spring_layout(barabasi_albert_graph, k<span class="op">=</span><span class="fl">0.15</span>, iterations<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb270-37"><a href="#cb270-37" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(barabasi_albert_graph, pos<span class="op">=</span>pos_barabasi_albert_graph, node_size<span class="op">=</span><span class="dv">10</span>, with_labels<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>axes[<span class="dv">2</span>, <span class="dv">1</span>])</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-42" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-42-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-42-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-42-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.44: Візуалізація графів: лінія, коло, зірка, Ердеш-Реньї, Малий світ і Переважне приєднання
</figcaption>
</figure>
</div>
</div>
</div>
<p>Кожен із даних графів може різнитись за своїми спектральними і топологічними властивостями: деякі можуть мати вищий ступінь кластеризації, ступеня вершини, посередництва тощо. Розглянемо як ранжується ступінь складності кожного графа за досліджуваними нами показниками.</p>
<p>Спочатку збережемо кожен із побудованих графів до одного масиву для ітеративного проведення розрахунків по кожному з них:</p>
<div id="1815d77a" class="cell" data-execution_count="168">
<div class="sourceCode cell-code" id="cb271"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>graphs <span class="op">=</span> [line_graph, cycle_graph, star_graph, erdos_renyi_graph, small_world_graph, barabasi_albert_graph] <span class="co"># графи</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> [<span class="st">'Лінія'</span>, <span class="st">'Коло'</span>, <span class="st">'Зірка'</span>, <span class="st">'Ердеш-Реньї'</span>, <span class="st">'Малий світ'</span>, <span class="st">'Переважне приєднання'</span>]                    <span class="co"># їх мітки</span></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'b'</span>, <span class="st">'purple'</span>, <span class="st">'red'</span>, <span class="st">'green'</span>, <span class="st">'pink'</span>, <span class="st">'black'</span>]</span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a>linestyles <span class="op">=</span> [<span class="st">'-'</span>, <span class="st">'-'</span>, <span class="st">'--'</span>, <span class="st">'--'</span>, <span class="st">':'</span>, <span class="st">'-'</span>]</span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> [<span class="st">'d'</span>, <span class="st">'v'</span>, <span class="st">'*'</span>, <span class="st">'s'</span>, <span class="st">'H'</span>, <span class="st">'o'</span>]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="спектральні-міри-складності-1" class="level3" data-number="13.2.1">
<h3 data-number="13.2.1" class="anchored" data-anchor-id="спектральні-міри-складності-1"><span class="header-section-number">13.2.1</span> Спектральні міри складності</h3>
<p>Тепер виконаємо розрахунки спектральних мір складності для кожного графа:</p>
<div id="1a38516c" class="cell" data-execution_count="180">
<div class="sourceCode cell-code" id="cb272"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>algebraic_connect_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>) </span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a>energy_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>)</span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>spec_gap_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>)</span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a>spec_mom_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>)</span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, graph <span class="kw">in</span> <span class="bu">enumerate</span>(graphs):</span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a>    algebraic_connect_vals[i] <span class="op">=</span> nx.algebraic_connectivity(graph, normalized<span class="op">=</span><span class="va">False</span>, method<span class="op">=</span><span class="st">'tracemin_lu'</span>)</span>
<span id="cb272-8"><a href="#cb272-8" aria-hidden="true" tabindex="-1"></a>    energy_vals[i] <span class="op">=</span> graph_energy(graph)</span>
<span id="cb272-9"><a href="#cb272-9" aria-hidden="true" tabindex="-1"></a>    spec_gap_vals[i] <span class="op">=</span> spectral_gap(graph)</span>
<span id="cb272-10"><a href="#cb272-10" aria-hidden="true" tabindex="-1"></a>    spec_mom_vals[i] <span class="op">=</span> spectral_moment(graph)</span>
<span id="cb272-11"><a href="#cb272-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-12"><a href="#cb272-12" aria-hidden="true" tabindex="-1"></a>num_rep <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb272-13"><a href="#cb272-13" aria-hidden="true" tabindex="-1"></a>algebraic_connect_vals <span class="op">=</span> np.repeat(algebraic_connect_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb272-14"><a href="#cb272-14" aria-hidden="true" tabindex="-1"></a>energy_vals <span class="op">=</span> np.repeat(energy_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb272-15"><a href="#cb272-15" aria-hidden="true" tabindex="-1"></a>spec_gap_vals <span class="op">=</span> np.repeat(spec_gap_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb272-16"><a href="#cb272-16" aria-hidden="true" tabindex="-1"></a>spec_mom_vals <span class="op">=</span> np.repeat(spec_mom_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Виведемо результат:</p>
<div id="cell-fig-spec" class="cell" data-execution_count="181">
<div class="sourceCode cell-code" id="cb273"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Зв'язність</span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Алгебраїчна зв</span><span class="ch">\'</span><span class="st">язність'</span>)</span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(algebraic_connect_vals[i], </span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb273-12"><a href="#cb273-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-13"><a href="#cb273-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-14"><a href="#cb273-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Енергія </span></span>
<span id="cb273-15"><a href="#cb273-15" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Енергія графа'</span>)</span>
<span id="cb273-16"><a href="#cb273-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb273-17"><a href="#cb273-17" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(energy_vals[i], </span>
<span id="cb273-18"><a href="#cb273-18" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb273-19"><a href="#cb273-19" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb273-20"><a href="#cb273-20" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb273-21"><a href="#cb273-21" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb273-22"><a href="#cb273-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb273-23"><a href="#cb273-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-24"><a href="#cb273-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Розрив</span></span>
<span id="cb273-25"><a href="#cb273-25" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Спектральний розрив'</span>)</span>
<span id="cb273-26"><a href="#cb273-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb273-27"><a href="#cb273-27" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(spec_gap_vals[i], </span>
<span id="cb273-28"><a href="#cb273-28" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb273-29"><a href="#cb273-29" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb273-30"><a href="#cb273-30" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb273-31"><a href="#cb273-31" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb273-32"><a href="#cb273-32" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb273-33"><a href="#cb273-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-34"><a href="#cb273-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Момент </span></span>
<span id="cb273-35"><a href="#cb273-35" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Спектральний момент'</span>)</span>
<span id="cb273-36"><a href="#cb273-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb273-37"><a href="#cb273-37" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(spec_mom_vals[i], </span>
<span id="cb273-38"><a href="#cb273-38" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb273-39"><a href="#cb273-39" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb273-40"><a href="#cb273-40" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb273-41"><a href="#cb273-41" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb273-42"><a href="#cb273-42" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb273-43"><a href="#cb273-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-44"><a href="#cb273-44" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span> </span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-spec" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spec-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-spec-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spec-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.45: Спектральні властивості канонічних і модельних графів: алгебраїчної зв’язності, енергії графа, спектрального розриву та спектрального моменту
</figcaption>
</figure>
</div>
</div>
</div>
<p>З рисунку (<a href="#fig-spec" class="quarto-xref">Рис.&nbsp;<span>13.45</span></a>) можна побачити наступне:</p>
<ul>
<li>по-перше, усі спектральні показники залишаються найбільшими саме для графа переважного приєднання, що представляється найбільш складним серед усіх інших графів;</li>
<li>по друге, згідно динаміки спектральних показників, найпростішими серед усіх графів є граф лінії, зірки та Ердеша-Реньї. Для лінії зберігається зв’язок тільки між парами послідовних вершин. Для зірки зберігається зв’язок усіх вершин із центром, але самі вони не пов’язані один із одним;</li>
<li>по третє, граф малого світу залишається другим за складністю майже за всіма показниками, окрім спектрального розриву. Спектральний розрив говорить, що граф зірки є трохи складнішим за граф малого світу. Це може бути обумовлене тим, що для зірки ми спостерігаємо достатньо високий ступінь централізації.</li>
</ul>
</section>
<section id="топологічні-міри" class="level3" data-number="13.2.2">
<h3 data-number="13.2.2" class="anchored" data-anchor-id="топологічні-міри"><span class="header-section-number">13.2.2</span> Топологічні міри</h3>
<p>Розрахуємо для досліджуваних графів топологічні міри складності. В якості прикладу розглянемо такі міри як</p>
<ul>
<li>максимальний ступінь вершини (<span class="math inline">\(d_{max}\)</span>);</li>
<li>глобальний коефіцієнт кластеризації (<span class="math inline">\(C\)</span>);</li>
<li>середній ступінь посередництва (<span class="math inline">\(B_{mean}\)</span>);</li>
<li>середня довжина найкоротшого шляху (<span class="math inline">\(L_{mean}\)</span>).</li>
</ul>
<div id="4dfa8426" class="cell" data-execution_count="182">
<div class="sourceCode cell-code" id="cb274"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a>max_degree_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>) </span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a>global_clust_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>)</span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a>mean_betweenness_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>)</span>
<span id="cb274-4"><a href="#cb274-4" aria-hidden="true" tabindex="-1"></a>mean_path_vals <span class="op">=</span> np.zeros(<span class="dv">6</span>)</span>
<span id="cb274-5"><a href="#cb274-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-6"><a href="#cb274-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, graph <span class="kw">in</span> <span class="bu">enumerate</span>(graphs):</span>
<span id="cb274-7"><a href="#cb274-7" aria-hidden="true" tabindex="-1"></a>    max_degree_vals[i] <span class="op">=</span> <span class="bu">max</span>(<span class="bu">dict</span>(graph.degree()).values())</span>
<span id="cb274-8"><a href="#cb274-8" aria-hidden="true" tabindex="-1"></a>    global_clust_vals[i] <span class="op">=</span> nx.average_clustering(graph)</span>
<span id="cb274-9"><a href="#cb274-9" aria-hidden="true" tabindex="-1"></a>    mean_betweenness_vals[i] <span class="op">=</span> np.mean(<span class="bu">list</span>(nx.betweenness_centrality(graph).values()))</span>
<span id="cb274-10"><a href="#cb274-10" aria-hidden="true" tabindex="-1"></a>    mean_path_vals[i] <span class="op">=</span> np.mean([nx.average_shortest_path_length(C) <span class="cf">for</span> C <span class="kw">in</span> </span>
<span id="cb274-11"><a href="#cb274-11" aria-hidden="true" tabindex="-1"></a>                                 (graph.subgraph(c).copy() <span class="cf">for</span> c <span class="kw">in</span> nx.connected_components(graph))])</span>
<span id="cb274-12"><a href="#cb274-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-13"><a href="#cb274-13" aria-hidden="true" tabindex="-1"></a>num_rep <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb274-14"><a href="#cb274-14" aria-hidden="true" tabindex="-1"></a>max_degree_vals <span class="op">=</span> np.repeat(max_degree_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb274-15"><a href="#cb274-15" aria-hidden="true" tabindex="-1"></a>global_clust_vals <span class="op">=</span> np.repeat(global_clust_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb274-16"><a href="#cb274-16" aria-hidden="true" tabindex="-1"></a>mean_betweenness_vals <span class="op">=</span> np.repeat(mean_betweenness_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb274-17"><a href="#cb274-17" aria-hidden="true" tabindex="-1"></a>mean_path_vals <span class="op">=</span> np.repeat(mean_path_vals[:, np.newaxis], num_rep, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Виводимо результат:</p>
<div id="cell-fig-topol" class="cell" data-execution_count="183">
<div class="sourceCode cell-code" id="cb275"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Макс. ступінь вершини'</span>)</span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(max_degree_vals[i], </span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb275-9"><a href="#cb275-9" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb275-10"><a href="#cb275-10" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb275-11"><a href="#cb275-11" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb275-12"><a href="#cb275-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-13"><a href="#cb275-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Енергія </span></span>
<span id="cb275-14"><a href="#cb275-14" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Глобальний коефіцієнт кластеризації'</span>)</span>
<span id="cb275-15"><a href="#cb275-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb275-16"><a href="#cb275-16" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(global_clust_vals[i], </span>
<span id="cb275-17"><a href="#cb275-17" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb275-18"><a href="#cb275-18" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb275-19"><a href="#cb275-19" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb275-20"><a href="#cb275-20" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb275-21"><a href="#cb275-21" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb275-22"><a href="#cb275-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-23"><a href="#cb275-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Розрив</span></span>
<span id="cb275-24"><a href="#cb275-24" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Середній ступінь посередництва'</span>)</span>
<span id="cb275-25"><a href="#cb275-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb275-26"><a href="#cb275-26" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(mean_betweenness_vals[i], </span>
<span id="cb275-27"><a href="#cb275-27" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb275-28"><a href="#cb275-28" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb275-29"><a href="#cb275-29" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb275-30"><a href="#cb275-30" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb275-31"><a href="#cb275-31" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb275-32"><a href="#cb275-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-33"><a href="#cb275-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Момент </span></span>
<span id="cb275-34"><a href="#cb275-34" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Середня довжина найкоротшого шляху'</span>)</span>
<span id="cb275-35"><a href="#cb275-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graphs)):</span>
<span id="cb275-36"><a href="#cb275-36" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(mean_path_vals[i], </span>
<span id="cb275-37"><a href="#cb275-37" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>colors[i], </span>
<span id="cb275-38"><a href="#cb275-38" aria-hidden="true" tabindex="-1"></a>                    marker<span class="op">=</span>markers[i], </span>
<span id="cb275-39"><a href="#cb275-39" aria-hidden="true" tabindex="-1"></a>                    linestyle<span class="op">=</span>linestyles[i], </span>
<span id="cb275-40"><a href="#cb275-40" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span>labels[i])</span>
<span id="cb275-41"><a href="#cb275-41" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend(fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb275-42"><a href="#cb275-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-43"><a href="#cb275-43" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span> </span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-topol" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-topol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lab_13_files/figure-html/fig-topol-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-topol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Рис.&nbsp;13.46: Топологічні міри складності канонічних і модельних графів: максимального значення ступеня вершини, глобального коефіцієнту кластеризації, середнього ступеня посередництва та середньої довжини найкоротшого шляху
</figcaption>
</figure>
</div>
</div>
</div>
<p>На рисунку (<a href="#fig-topol" class="quarto-xref">Рис.&nbsp;<span>13.46</span></a>) можна побачити наступне:</p>
<ul>
<li>по-перше, найбільшим максимальним ступенем вершини характеризується саме граф-зірка, центр якої з’єднаний абсолютно з усіма вершинами мережі. Другим по ступенем концентрованності йде граф переважного приєднання, що, як ми вже зазначали, є найкращою моделлю реальних соціальних систем. До найпростіших можна віднести графи лінії, кола та Ердеша-Реньї;</li>
<li>по-друге, глобальний коефіцієнт кластеризації вказує на те, що найвищий ступінь кластеризації спостерігається саме для графа малого світу. Закономірно за ним іде граф переважного приєднання. Найпростішими знову виявляються графи Ердеша-Реньї, лінії, кола та, цього разу, зірки. Для зірки навіть візуально видно, що всі вершини мають тенденцію слідувати тільки за однією конкретною;</li>
<li>по-третє, середній ступінь посередництва є найнижчим для зірки, графа Ердеша-Реньї, малого світу та переважного приєднання. Для цих мереж передача інформації від одного вузла до іншого не займає значну частку часу. Для лінії та кола від одного кінця графа до іншого може знадобитися досить великий проміжок часу для передачі інформації. Схожа ситуація спостерігається й для середньої довжини найкоротшого шляху, оскільки міра посередництва на пряму залежить від значення найкоротшого шляху від одного вузла до іншого.</li>
</ul>
</section>
</section>
<section id="висновок" class="level2" data-number="13.3">
<h2 data-number="13.3" class="anchored" data-anchor-id="висновок"><span class="header-section-number">13.3</span> Висновок</h2>
<p>У даній лабораторній роботі було здійснено вступ до теорії графів і різних кількісних показників, що вона надає. На прикладі простих графів і мереж реального світу було показано, що графові показники дозволяють кількісно визначити ступінь ефективності, концентрованості, кластеризації, зв’язності тощо. Було показано, що графам реального світу властиві степенева залежність розподілу ступенів вершин, низька довжина найкоротшого шляху та високий ступінь кластеризації. У лабораторній <a href="lab_14.html" class="quarto-xref"><span>Глава 14</span></a> буде розширено спектр мережних показників і продемонстровано змогу їх використання в якості індикаторів-передвісників крахових подій.</p>
</section>
<section id="завдання-для-самостійної-роботи" class="level2" data-number="13.4">
<h2 data-number="13.4" class="anchored" data-anchor-id="завдання-для-самостійної-роботи"><span class="header-section-number">13.4</span> Завдання для самостійної роботи</h2>
<ol type="1">
<li>Проаналізуйте аналогічно інші з розрахованих мір складності як спектральних, так і топологічних</li>
<li>Вкажіть і аргументуйте, які з них, на вашу думку, кількісно описують складність досліджуваних мереж?</li>
<li>Побудуйте залежність різних мережних показників для часового ряду реального світу по аналогії з двома попередніми рисунками</li>
</ol>


<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-watts1998collective" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">D. J. Watts and S. H. Strogatz, <a href="https://doi.org/10.1038/30918">Collective dynamics of ’small-world’ networks</a>, Nature <strong>393</strong>, 440 (1998).</div>
</div>
<div id="ref-doi:10.1126/science.286.5439.509" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">A.-L. Barabási and R. Albert, <a href="https://doi.org/10.1126/science.286.5439.509">Emergence of scaling in random networks</a>, Science <strong>286</strong>, 509 (1999).</div>
</div>
<div id="ref-RevModPhys.74.47" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">R. Albert and A.-L. Barabási, <a href="https://doi.org/10.1103/RevModPhys.74.47">Statistical mechanics of complex networks</a>, Rev. Mod. Phys. <strong>74</strong>, 47 (2002).</div>
</div>
<div id="ref-platt2019network" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">E. L. Platt, <em><a href="https://www.packtpub.com/product/network-science-with-python-and-networkx-quick-start-guide/9781789955316">Network Science with Python and NetworkX Quick Start Guide: Explore and Visualize Network Data Effectively</a></em> (Packt Publishing, 2019).</div>
</div>
<div id="ref-cormen2022introduction" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, <em><a href="https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/">Introduction to Algorithms, Fourth Edition</a></em> (MIT Press, 2022).</div>
</div>
<div id="ref-TRAVERS1977179" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">J. Travers and S. Milgram, <em><a href="https://doi.org/10.1016/B978-0-12-442450-0.50018-3">An Experimental Study of the Small World Problem</a></em>, in <em>Social Networks</em>, edited by S. Leinhardt (Academic Press, 1977), pp. 179–197.</div>
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Скопійовано!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Скопійовано!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/butman2099\.github\.io\/Complex-systems-book\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="./lab_12.html" class="pagination-link" aria-label="Лабораторна робота № 12">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Лабораторна робота № 12</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./lab_14.html" class="pagination-link" aria-label="Лабораторна робота № 14">
        <span class="nav-page-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Лабораторна робота № 14</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.dev/Butman2099/Complex-systems-book/blob/main/lab_13.ipynb" class="toc-action"><i class="bi bi-github"></i>Редагувати сторінку</a></li></ul></div></div></div></footer></body></html>